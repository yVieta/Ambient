<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ambient Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style.min.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="user/installing.html"><strong aria-hidden="true">1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="user/setting_up_ide.html"><strong aria-hidden="true">2.</strong> Setting up your IDE</a></li><li class="chapter-item expanded "><a href="user/overview.html"><strong aria-hidden="true">3.</strong> Overview</a></li><li class="chapter-item expanded "><a href="user/running_examples.html"><strong aria-hidden="true">4.</strong> Running examples</a></li><li class="chapter-item expanded "><a href="user/api.html"><strong aria-hidden="true">5.</strong> API</a></li><li class="chapter-item expanded "><a href="user/debugging.html"><strong aria-hidden="true">6.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="user/profiling.html"><strong aria-hidden="true">7.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="user/settings.html"><strong aria-hidden="true">8.</strong> Settings</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorials/game/0_intro.html"><strong aria-hidden="true">9.</strong> Intro</a></li><li class="chapter-item expanded "><a href="tutorials/game/1_package.html"><strong aria-hidden="true">10.</strong> Chapter 1: Creating a project</a></li><li class="chapter-item expanded "><a href="tutorials/game/2_player_character.html"><strong aria-hidden="true">11.</strong> Chapter 2: Player character</a></li><li class="chapter-item expanded "><a href="tutorials/game/3_scene.html"><strong aria-hidden="true">12.</strong> Chapter 3: Scene</a></li><li class="chapter-item expanded "><a href="tutorials/game/4_player_interaction.html"><strong aria-hidden="true">13.</strong> Chapter 4: Player interaction</a></li><li class="chapter-item expanded "><a href="tutorials/game/5_models.html"><strong aria-hidden="true">14.</strong> Chapter 5: Models</a></li><li class="chapter-item expanded "><a href="tutorials/game/6_ui.html"><strong aria-hidden="true">15.</strong> Chapter 6: UI</a></li><li class="chapter-item expanded "><a href="tutorials/game/7_deploying.html"><strong aria-hidden="true">16.</strong> Chapter 7: Deploying</a></li><li class="chapter-item expanded "><a href="tutorials/game/8_modding.html"><strong aria-hidden="true">17.</strong> Chapter 8: Modding</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="reference/getting_content.html"><strong aria-hidden="true">18.</strong> Getting content</a></li><li class="chapter-item expanded "><a href="reference/runtime.html"><strong aria-hidden="true">19.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="reference/package.html"><strong aria-hidden="true">20.</strong> Package</a></li><li class="chapter-item expanded "><a href="reference/ecs.html"><strong aria-hidden="true">21.</strong> ECS</a></li><li class="chapter-item expanded "><a href="reference/messages.html"><strong aria-hidden="true">22.</strong> Messages</a></li><li class="chapter-item expanded "><a href="reference/models.html"><strong aria-hidden="true">23.</strong> Models</a></li><li class="chapter-item expanded "><a href="reference/hierarchies.html"><strong aria-hidden="true">24.</strong> Hierarchies and transforms</a></li><li class="chapter-item expanded "><a href="reference/asset_pipeline.html"><strong aria-hidden="true">25.</strong> Asset pipeline</a></li><li class="chapter-item expanded "><a href="reference/networking.html"><strong aria-hidden="true">26.</strong> Networking</a></li><li class="chapter-item expanded "><a href="reference/animations.html"><strong aria-hidden="true">27.</strong> Animations</a></li><li class="chapter-item expanded "><a href="reference/physics.html"><strong aria-hidden="true">28.</strong> Physics</a></li><li class="chapter-item expanded "><a href="reference/audio.html"><strong aria-hidden="true">29.</strong> Audio</a></li><li class="chapter-item expanded "><a href="reference/ui.html"><strong aria-hidden="true">30.</strong> UI</a></li><li class="chapter-item expanded "><a href="reference/distributing.html"><strong aria-hidden="true">31.</strong> Distributing</a></li><li class="chapter-item expanded "><a href="reference/ci.html"><strong aria-hidden="true">32.</strong> CI</a></li><li class="chapter-item expanded "><a href="reference/terminology.html"><strong aria-hidden="true">33.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="reference/common_pitfalls.html"><strong aria-hidden="true">34.</strong> Common pitfalls</a></li><li class="chapter-item expanded "><a href="reference/advanced_installing.html"><strong aria-hidden="true">35.</strong> Advanced installation</a></li><li class="chapter-item expanded "><a href="reference/faq.html"><strong aria-hidden="true">36.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="reference/changelog.html"><strong aria-hidden="true">37.</strong> Changelog</a></li><li class="chapter-item expanded affix "><li class="part-title">Runtime internals</li><li class="chapter-item expanded "><a href="runtime_internals/overview.html"><strong aria-hidden="true">38.</strong> Overview</a></li><li class="chapter-item expanded "><a href="runtime_internals/contributing.html"><strong aria-hidden="true">39.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="runtime_internals/ecs.html"><strong aria-hidden="true">40.</strong> ECS</a></li><li class="chapter-item expanded "><a href="runtime_internals/renderer.html"><strong aria-hidden="true">41.</strong> Renderer</a></li><li class="chapter-item expanded "><a href="runtime_internals/asset_cache.html"><strong aria-hidden="true">42.</strong> Asset cache</a></li><li class="chapter-item expanded "><a href="runtime_internals/guidelines.html"><strong aria-hidden="true">43.</strong> Guidelines</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ambient Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/AmbientRun/Ambient" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ambient is an open-source cross-platform runtime and platform for building, deploying and sharing high-performance multiplayer games on the web, desktop, and elsewhere. Powered by Rust, WebAssembly (WASM), and WebGPU, Ambient is cutting-edge while staying true to its goal: making game development both fun and accessible.</p>
<p>To set the scene: the Ambient runtime is an extensible multiplayer game engine with an in-game real-time database, automatic synchronization, Rust-inspired interoperable packages, an asset pipeline, WASM-powered isolation, PBR rendering, and more.</p>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>At the core of Ambient lies <a href="./reference/ecs.html">an entity component system (ECS)</a> that forms the backbone of its data model - it’s a real-time database for your game and everything running within it. <em>Entities</em> contain <em>components</em>, which are typed pieces of data, and these are acted upon with <em>systems</em>.</p>
<p>Networked components are automatically synchronized to all clients, ensuring a consistent experience across all players; instead of grappling with complex networking intricacies, developers can focus on building their server and client-side logic.</p>
<p>In Ambient, everything is an entity with components, including the data of the runtime itself, ensuring that nothing is off-limits and all is accessible to developers. If you can see the data, you can use it.</p>
<h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<p>Experiences in Ambient are composed of <a href="./reference/package.html">packages</a>, which are bundles of code, assets and schema definitions. Packages can communicate with each other seamlessly through their schemas, allowing for structured, dynamic interoperability. Packages can be mixed and matched to create unique experiences, <!-- and they can be hot-reloaded on the fly, --> making Ambient the ultimate sandbox for multiplayer game development.</p>
<p>Packages can be deployed to the platform for other users to make use of, or to build on top of. Ambient offers a Rust-inspired package manager and tooling. Users specify dependencies in their package’s manifest in a fashion similar to <code>Cargo.toml</code>. Rust programmers will feel at home, and non-Rust programmers will find the experience intuitive and easy to use.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>All assets, including code, are streamed to players when they connect to the server; users do not have to download anything to start playing games immediately<!--, and developers can swap out assets as required during development without having to restart the server -->.</p>
<!-- With hot-reloading capabilities, you can make changes to your game logic and assets and see the results instantly, reducing development time and increasing productivity. This flexibility enables experimentation and rapid iteration, so that developers can focus on the most important part of game development: making fun games, quickly. -->
<p>Ambient’s <a href="./reference/asset_pipeline.html">asset pipeline</a> supports a wide range of formats, including <code>.glb</code> and <code>.fbx</code>. The asset pipeline is flexible and can be extended to support additional formats as required. This approach ensures that developers can use their preferred tools and workflows without having to worry about compatibility issues.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p><a href="./reference/package.html#webassembly">WebAssembly (WASM)</a> is the secret sauce that enables Ambient’s capabilities. Every package’s code in Ambient operates within the confines of WebAssembly, ensuring a high level of isolation. Ambient pushes WASM to its absolute limits; on the web, WASM is used both to run the Ambient runtime and to execute user code, making it one of the most ambitious WASM projects to date.</p>
<p>Safety and stability are paramount. Thanks to the power of WebAssembly, code for Ambient runs in isolation. This means that if something within a package crashes, it won’t bring down the entire program. Furthermore, the isolation provided by WebAssembly ensures that you can run untrusted code safely, enhancing security in multiplayer environments. This extends to embedding existing C/C++ libraries, which can be compiled to WebAssembly and used in Ambient packages.</p>
<h2 id="rendering"><a class="header" href="#rendering">Rendering</a></h2>
<p>At the heart of the Ambient renderer lies WebGPU, a cutting-edge technology that unleashes the potential of modern graphics hardware on the Web and beyond. By default, the renderer supports Physically Based Rendering (PBR) and offers advanced features such as cascading shadow maps and seamless instancing.</p>
<p>In future, the renderer will be made extensible, so that developers can define the visual style of their games as they see fit. This approach ensures that Ambient can be used to create a wide range of experiences, from realistic simulations to stylized games.</p>
<h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p>Ambient’s philosophy is based around flexibility and experimentation, empowering developers to push the boundaries in the ultimate game development sandbox. As Ambient develops, more and more functionality will be moved from the runtime to the realm of developers, ensuring that there are no limits on creativity.</p>
<p>Fundamentally, we are excited about the future of game creation. We would like to see completely new forms of games emerging, which we believe will only happen when game creation tools evolve into the next generation. We hope to usher in this new era with Ambient.</p>
<p>We want to forge a game creation platform that unleashes your creative energy and empowers you to share that fiery passion with the world - so that, one day, we can experience your dreams-made-real for ourselves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing"><a class="header" href="#installing">Installing</a></h1>
<p>Native use of Ambient, for both developing and playing games, is easy. We have a version manager that
will retrieve a pre-built version of Ambient for your platform. This is the recommended way to use Ambient.</p>
<p>The steps are as follows, where the commands are for your terminal of choice:</p>
<ol>
<li>
<p><a href="https://www.rust-lang.org/">Install Rust</a>. Note that the minimum supported version is 1.71.0, and you may need to update.</p>
</li>
<li>
<p>Add the <code>wasm32-wasi</code> toolchain. This lets you compile Rust code for Ambient.</p>
<pre><code>rustup target add --toolchain stable wasm32-wasi
</code></pre>
</li>
<li>
<p>Install the Ambient version manager:</p>
<pre><code>cargo install ambient
</code></pre>
</li>
</ol>
<p>The native client of Ambient currently runs on Windows, Linux and macOS.</p>
<blockquote>
<p><strong>Warning</strong>: If you are using Command Prompt on Windows, ensure that you do not have an <code>ambient</code> executable in the directory that you are running the command from.</p>
<p>This is because Command Prompt will prefer the local executable over the one installed by Cargo.</p>
</blockquote>
<p>Next, try the <a href="user/../tutorials/game/0_intro.html">tutorial</a> to create your first Ambient game!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-your-ide"><a class="header" href="#setting-up-your-ide">Setting up your IDE</a></h1>
<p>Our recommended IDE is Visual Studio Code (VSCode).</p>
<h2 id="visual-studio-code-vscode"><a class="header" href="#visual-studio-code-vscode">Visual Studio Code (VSCode)</a></h2>
<p>Install <a href="https://code.visualstudio.com/">Visual Studio Code</a>, then install the following plugins:</p>
<ul>
<li><a href="https://rust-analyzer.github.io/">rust-analyzer</a>, as described <a href="https://code.visualstudio.com/docs/languages/rust">here</a>.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a>. This extension is optional, but enables package launching with F5 and will be used to provide debugging support in the future.</li>
</ul>
<p><code>ambient new</code> will set up your package for VSCode by default by creating a <code>.vscode/settings.json</code> for you.</p>
<blockquote>
<p>Mac users: There is currently a bug which triggers a SIGHUP crash each time you close Ambient, when it’s started through VSCode. For a fix and more details, see this issue: https://github.com/AmbientRun/Ambient/issues/909</p>
</blockquote>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>There are multiple ways to configure Emacs as a Rust IDE. The following assumes you are using <a href="https://github.com/brotzeit/rustic">rustic</a>,
<a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> and <a href="https://rust-analyzer.github.io/">rust-analyzer</a> libraries. Robert Krahn provides a <a href="https://robert.kra.hn/posts/rust-emacs-setup/#prerequisites">comprehensive guide to configuring Emacs for Rust development</a>.</p>
<p>Once you have Emacs configured for general Rust development, you need to set some explicit values for Ambient packages. Ambient uses some custom <code>cargo</code> configuration values that Emacs and rust-analyzer need to know about. You can manually set these variables with the following <code>elisp</code>:</p>
<pre><code class="language-elisp">  (setq lsp-rust-analyzer-cargo-target &quot;wasm32-wasi&quot;
        lsp-rust-analyzer-cargo-watch-args [&quot;--features&quot; &quot;client server&quot;]
        lsp-rust-features [&quot;client&quot; &quot;server&quot;])
</code></pre>
<p>Furthermore, you can add a <code>.dir-locals.el</code> file to your Ambient package directory that Emacs will pick up and load settings for. This is similar to the <code>.vscode/settings.json</code> that is created by default. This is an example <code>.dir-locals.el</code> file:</p>
<pre><code class="language-elisp">((rustic-mode . ((eval . (setq-local lsp-rust-analyzer-cargo-target &quot;wasm32-wasi&quot;))
                 (eval . (setq-local lsp-rust-analyzer-cargo-watch-args [&quot;--features&quot; &quot;client server&quot;]))
                 (eval . (setq-local lsp-rust-features [&quot;client&quot; &quot;server&quot;])))))
</code></pre>
<h2 id="other-ides"><a class="header" href="#other-ides">Other IDEs</a></h2>
<p>To get rust-analyzer to work, you need to make sure it’s building with the <code>server</code> and <code>client</code> feature flags enabled. See <a href="https://github.com/AmbientRun/Ambient/blob/main/app/src/cli/package/new_package_template/.vscode/settings.json">.vscode/settings.json</a> for an example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-ambient"><a class="header" href="#overview-of-ambient">Overview of Ambient</a></h1>
<p>Let’s start with a rough overview of Ambient to give you an idea of how it works.</p>
<h2 id="the-database-ecs"><a class="header" href="#the-database-ecs">The database (ECS)</a></h2>
<p>The most central thing in Ambient is the <a href="user/../reference/ecs.html">ECS</a> “world”. You can think of it
as a database that stores everything in your application.</p>
<p>The world is a collection of entities. An entity is a collection of components and a component is a
<code>(name, value)</code> pair. For example, you could have an entity with two components:</p>
<pre><code class="language-yml">entity 1932:
  - translation: (5, 2, 0)
  - color: (1, 0, 0, 1)
</code></pre>
<p>If you compare this to a traditional SQL database, you can think of entities as rows and
components as columns. Note that there is no equivalent of a table, though: any component can be attached to any
entity.</p>
<h2 id="clientserver"><a class="header" href="#clientserver">Client/server</a></h2>
<p>The next thing to know is that Ambient is built around a client/server architecture. Both
the server and the client have a world of their own (green and blue boxes in the image below).</p>
<p><img src="user/server_client.png" alt="Server client architecture" /></p>
<p>The server’s world is automatically replicated to all clients’ worlds. The clients can
add additional entities and/or components to their local world. Typically, you’ll
have game state on the server (for instance <code>{ unit: &quot;orc&quot;, level: 10 }</code>), and visual
effects or other client-local state on the clients (for instance, spawn fireworks when
the orc levels up).</p>
<p>Note that the replication is one-way.
Any changes you make to your client world will <em>not</em> be replicated to the server.
To communicate from the client to the server, you will typically use <a href="user/../reference/networking.html#messaging">message passing</a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-examples"><a class="header" href="#running-examples">Running examples</a></h1>
<p>You can either run the examples from the latest released version of Ambient, or with the development <code>main</code> branch.</p>
<p>However, <strong>the version of Ambient must match the version that the examples were built for</strong>. For instance, if you are running the <code>main</code> branch of Ambient, you must also run the <code>main</code> branch of the examples.</p>
<p>We recommend that you use the examples from the Ambient website, as they have a version associated
with them.</p>
<h2 id="running-examples-from-main"><a class="header" href="#running-examples-from-main">Running examples from main</a></h2>
<ol>
<li>Clone the GitHub repository.</li>
<li>Install Ambient with <code>cargo install --path app ambient</code>.</li>
<li>Run the examples in the <code>guest/rust/example</code> directory: <code>ambient run guest/rust/examples/basics/primitives</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<h2 id="reference-documentation"><a class="header" href="#reference-documentation">Reference documentation</a></h2>
<p>The full API reference for Ambient can be found on <a href="https://docs.rs/ambient_api">docs.rs</a>.</p>
<p>Note that the published API may not be up to date with the latest Git commit of the runtime - if you are using bleeding-edge features, you will need to document the API yourself using <code>cargo doc -p ambient_api</code> in the <code>guest/rust</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="running-with-the-debugger"><a class="header" href="#running-with-the-debugger">Running with the debugger</a></h2>
<p>When the client is run with the <code>AMBIENT_DEBUGGER</code> environment variable, or with the <code>--debugger</code> flag, the game is surrounded with a debugger:</p>
<pre><code class="language-sh">AMBIENT_DEBUGGER=1 ambient run examples/minigolf
# or `$env:AMBIENT_DEBUGGER=1` on Windows/PowerShell
# or `ambient run --debugger examples/minigolf`
</code></pre>
<p><img src="user/debugger.png" alt="Debugger surrounding the game with AMBIENT_DEBUGGER" /></p>
<p>These can be used to inspect the state of the client and server ECSes, as well as the renderer. When one of these buttons are pressed, a YAML file will be created with the corresponding state, and its path will be written to <code>stdout</code>:</p>
<pre><code class="language-log">[2023-02-23T17:47:36Z INFO  ambient_debugger] Wrote &quot;Ambient/tmp/server_hierarchy.yml&quot;
</code></pre>
<p>Here is some sample output for the server ECS:</p>
<pre><code class="language-yaml">- &quot;id=RsE148MNkdB24bFWQrfeMA loc=48:0&quot;:
    &quot;core::app::main_scene&quot;: ()
    &quot;core::ecs::children&quot;: &quot;[EntityId(koK-dbeCZDrcHzsT7QELUw, 110383077981027712353063371358575952530)]&quot;
    &quot;core::transform::translation&quot;: &quot;Vec3(-5.0, -0.0019752309, 2.8536541)&quot;
    &quot;core::transform::scale&quot;: &quot;Vec3(1.0, 1.0, 1.0)&quot;
    &quot;core::transform::rotation&quot;: &quot;Quat(0.0, 0.0, 0.0, 1.0)&quot;
    &quot;core::transform::local_to_world&quot;: &quot;Mat4 { x_axis: Vec4(1.0, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, 1.0, 0.0, 0.0), z_axis: Vec4(0.0, 0.0, 1.0, 0.0), w_axis: Vec4(-5.0, -0.001970334, 2.8387475, 1.0) }&quot;
    &quot;core::transform::spherical_billboard&quot;: ()
  children:
    - &quot;id=koK-dbeCZDrcHzsT7QELUw loc=46:0&quot;:
        &quot;core::app::main_scene&quot;: ()
        &quot;core::transform::local_to_world&quot;: &quot;Mat4 { x_axis: Vec4(0.02, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, -0.02, 1.7484555e-9, 0.0), z_axis: Vec4(0.0, -1.7484555e-9, -0.02, 0.0), w_axis: Vec4(-5.0, -0.001970334, 2.8387475, 1.0) }&quot;
        &quot;core::transform::local_to_parent&quot;: &quot;Mat4 { x_axis: Vec4(0.02, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, -0.02, 1.7484555e-9, 0.0), z_axis: Vec4(0.0, -1.7484555e-9, -0.02, 0.0), w_axis: Vec4(0.0, 0.0, 0.0, 1.0) }&quot;
        &quot;core::transform::mesh_to_local&quot;: &quot;Mat4 { x_axis: Vec4(1.0, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, 1.0, 0.0, 0.0), z_axis: Vec4(0.0, 0.0, 1.0, 0.0), w_axis: Vec4(0.0, 0.0, 0.0, 1.0) }&quot;
        &quot;core::transform::mesh_to_world&quot;: &quot;Mat4 { x_axis: Vec4(0.02, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, -0.02, 1.7484555e-9, 0.0), z_axis: Vec4(0.0, -1.7484555e-9, -0.02, 0.0), w_axis: Vec4(-5.0, -0.001970334, 2.8387475, 1.0) }&quot;
        &quot;core::rendering::color&quot;: &quot;Vec4(1.0, 0.3, 0.3, 1.0)&quot;
        &quot;core::ui::text&quot;: '&quot;user_470i61dDp7FKjGFQetZ53O&quot;'
        &quot;core::ui::font_size&quot;: &quot;36.0&quot;
        &quot;core::player::user_id&quot;: &quot;...&quot;
      children: []
</code></pre>
<h2 id="increasing-log-output"><a class="header" href="#increasing-log-output">Increasing log output</a></h2>
<p>You can also increase the logging output from specific internal modules using the <code>RUST_LOG</code> environment variable,
which accepts <code>module=log_level</code> pairs that are comma-sepparated. Here are some general tips:</p>
<ul>
<li>To debug <strong>your asset pipeline</strong>, set <code>RUST_LOG=ambient_build=info</code>. For even more logs, you can set <code>RUST_LOG=ambient_build=info,ambient_model_import=info</code>.</li>
<li>To debug <strong>rendering</strong>, set <code>RUST_LOG=ambient_renderer=info</code>.</li>
<li>To debug <strong>networking</strong>, set <code>RUST_LOG=ambient_network=info</code>.</li>
<li>To debug <strong>physics</strong>, set <code>RUST_LOG=ambient_physics=info</code>.</li>
<li>To debug everything, set <code>RUST_LOG=info</code>. To get even more logs set <code>RUST_LOG=debug</code>.</li>
</ul>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>Ambient uses PhysX 4.1 from Nvidia for physics simulation. As a result, the entire physics scene can be visualized using the <a href="https://developer.nvidia.com/physx-visual-debugger">PhysX Visual Debugger (PVD)</a>.</p>
<p>By default, physics debugging is on. To debug your scene, install and start PVD, then start an Ambient package. Your package’s scene should automatically be visible within PVD. For more details on how to use PVD, see the <a href="https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/VisualDebugger.html">guide</a>.</p>
<h2 id="assets-1"><a class="header" href="#assets-1">Assets</a></h2>
<p>When assets are compiled by the assets pipeline, the resulting artifacts will be output to the <code>build</code> directory in your package. These can be examined to determine whether or not your source was accurately compiled by the asset pipeline.</p>
<p>Additionally, if there are fatal errors or warnings, the asset pipeline will report them during the compilation process.</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="debugging-which-components-are-sent-over-the-network"><a class="header" href="#debugging-which-components-are-sent-over-the-network">Debugging which components are sent over the network</a></h3>
<p>Use the environment flag <code>AMBIENT_DEBUG_ENTITY_STREAM</code> to debug entities and components sent over the network to the client. <code>AMBIENT_DEBUG_ENTITY_STREAM=FULL</code> will output everything, <code>AMBIENT_DEBUG_ENTITY_STREAM=true</code> (or anything else) will output a summary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling"><a class="header" href="#profiling">Profiling</a></h1>
<p>Ambient supports profiling through <a href="https://github.com/EmbarkStudios/puffin">puffin</a>. To use it, follow these steps:</p>
<ol>
<li>
<p>Build Ambient with profiling enabled (add the <code>profile</code> feature flag). From the root folder:</p>
<pre><code class="language-sh">cargo install --path app --features profile
</code></pre>
</li>
<li>
<p>Install <a href="https://crates.io/crates/puffin_viewer">puffin_viewer</a>:</p>
<pre><code class="language-sh">cargo install puffin_viewer
</code></pre>
</li>
<li>
<p>Start Ambient:</p>
<pre><code class="language-sh">ambient run guest/examples/basics/primitives
</code></pre>
</li>
<li>
<p>Start <code>puffin_viewer</code>:</p>
<pre><code class="language-sh">puffin_viewer
</code></pre>
</li>
</ol>
<p>You should now see real-time performance metrics for Ambient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>Ambient supports a number of settings that can be configured using the <code>settings.toml</code> file. This file is located under the platform’s config directory:</p>
<ul>
<li>Windows: <code>C:\Users\*USER*\AppData\Roaming\Ambient\Ambient\config\settings.toml</code></li>
<li>MacOS: <code>~/Library/Application\ Support/com.Ambient.Ambient/settings.toml</code></li>
<li>Linux: <code>~/.config/Ambient/settings.toml</code></li>
</ul>
<h2 id="settings-1"><a class="header" href="#settings-1">Settings</a></h2>
<pre><code class="language-toml">[general]
user_id = String
api_token = String

[general.sentry]
enabled = bool
dsn = String

[render]
resolution = [int, int]
vsync = bool
render_mode = String # &quot;MultiIndirect&quot;, &quot;Indirect&quot;, &quot;Direct&quot;
software_culling = bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-building-a-game-from-scratch"><a class="header" href="#tutorial-building-a-game-from-scratch">Tutorial: Building a game from scratch</a></h1>
<p>In this tutorial, our goal is to write a simple third-person shooter game and to demonstrate the capabilities of Ambient.</p>
<p>During this, we will show you the basic features of the engine, providing resources such as documentation, reference, examples, games, and more. At the end of the tutorial, you should have an understanding of how to use Ambient to make your own game.</p>
<p>If you run into any problems with the tutorial, please <a href="https://github.com/AmbientRun/Ambient/issues/new">open an issue</a> or <a href="https://discord.gg/ambient">join our Discord server</a> and let us know.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>To start with, you will need to install Ambient. Follow the documentation on <a href="tutorials/game/../../user/installing.html">how to install</a> (note that you will need to return to this page after installation).</p>
<p>If you are new to Rust, you can learn the basics of the language from <a href="https://www.rust-lang.org/learn">the official Rust website</a>. However, the API is designed to be easy to use, so you should be able to follow along even if you are new to Rust.</p>
<blockquote>
<p>Tip: If you prefer other methods for installation, see <a href="tutorials/game/../../reference/advanced_installing.html">here</a>.</p>
</blockquote>
<p>For the best experience, we recommend configuring your IDE for Ambient (see <a href="tutorials/game/../../user/setting_up_ide.html">here</a>).</p>
<h2 id="-chapter-1-creating-a-project"><a class="header" href="#-chapter-1-creating-a-project"><a href="tutorials/game/./1_package.html">⇾ Chapter 1: Creating a project</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-creating-a-package"><a class="header" href="#chapter-1-creating-a-package">Chapter 1: Creating a package</a></h1>
<p>To create a new Ambient project, type the following in your terminal of choice after having <a href="tutorials/game/../../user/installing.html">installed Ambient</a>:</p>
<pre><code class="language-sh">ambient new my_project
</code></pre>
<blockquote>
<p><strong>Note</strong>: Initial build times can be slow, especially on Windows, where Rust compilation is slower. Subsequent builds will be faster.</p>
</blockquote>
<p>This will create a new Ambient package with the default template, which is set up for Rust and creates a quad and a camera.</p>
<blockquote>
<p><strong>In-depth</strong>: A package is a bundle of code and assets which can be deployed. Read more about packages <a href="tutorials/game/../../reference/package.html">here</a>.</p>
</blockquote>
<p>Enter the project folder by typing <code>cd my_project</code>, and then run it with:</p>
<pre><code class="language-sh">ambient run
</code></pre>
<p>You should see a window like this:</p>
<p><img src="tutorials/game/template.png" alt="Ambient window" /></p>
<blockquote>
<p><strong>Tip</strong>: You can also open the project in VS Code by typing <code>code .</code> in the folder, <code>code my_project</code> from the root folder, or using the right-click menu of your operating system if supported.</p>
</blockquote>
<blockquote>
<p><strong>Tip</strong>: In VS Code, you can hit <code>F5</code> to run the project.</p>
</blockquote>
<blockquote>
<p><strong>Tip</strong>: Run with <code>--debugger</code> to show the debugger UI (i.e. <code>ambient run --debugger</code>). See the <a href="tutorials/game/../../user/debugging.html">reference documentation on debugging</a> for more info.
In VS Code, you can switch to the “Debug” launch configuration and then press <code>F5</code> to do the same.</p>
</blockquote>
<p>If you would like to join the session from the same machine with a second client, you can run:</p>
<pre><code class="language-sh">ambient join
</code></pre>
<p>However, within Ambient’s console output, a line should be present that looks like this:</p>
<pre><code>Proxy allocated an endpoint, use `<span style="color:green">ambient join proxy-eu.ambient.run:9898</span>` to join</code></pre>
<p>This can be used to quickly test a multiplayer game with another machine or with other people. Just copy the green text and send it to a friend to allow them to join your session.</p>
<h2 id="package-structure"><a class="header" href="#package-structure">Package structure</a></h2>
<p>The basic structure of an Ambient package is as follows:</p>
<ul>
<li><code>my_package/</code>
<ul>
<li><code>ambient.toml</code>: This is where you define ECS components, messages and other data about your package.</li>
<li><code>Cargo.toml</code>: This is Rust’s equivalent of <code>ambient.toml</code>, which defines Rust-specific metadata like Rust dependencies and more.</li>
<li><code>assets/</code>: This folder contains all assets.
<ul>
<li><code>pipeline.toml</code>: A pipeline file decides how the assets will be processsed.</li>
</ul>
</li>
<li><code>src/</code>: This folder contains all source code.
<ul>
<li><code>client.rs</code>: This file contains the code that run on your player’s computers.</li>
<li><code>server.rs</code>: This file contains code that runs on the game server.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>In-depth</strong>: You can read more about Ambient’s ECS <a href="tutorials/game/../../reference/ecs.html">in the ECS reference</a>, and about Ambient’s asset pipeline <a href="tutorials/game/../../reference/asset_pipeline.html">in the asset pipeline reference</a>.</p>
</blockquote>
<h2 id="client-and-server"><a class="header" href="#client-and-server">Client and server?</a></h2>
<p>Ambient targets multiplayer by default, which is why each new package comes with a <code>server.rs</code> and <code>client.rs</code>. Game logic is typically defined on the server, whereas the client forwards inputs and adds visual effects.</p>
<blockquote>
<p><strong>In-depth</strong>: For an introduction to the client-server architecture, <a href="tutorials/game/../../user/overview.html">go here</a>.</p>
</blockquote>
<blockquote>
<p><strong>Tip</strong>: Unsure about how to arrange your code? Check out <a href="tutorials/game/../../reference/faq.html#should-my-code-go-on-the-client-or-the-server">where my code should go</a>.</p>
</blockquote>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE setup</a></h2>
<p>If you have installed the <a href="tutorials/game/../../user/setting_up_ide.html">recommended VS Code tools</a>, you should be able to hover your mouse over each concept or component to see the docs. The following screenshot is of <code>server.rs</code>:</p>
<p><img src="tutorials/game/hint.png" alt="Code hint" /></p>
<p>This will also give you auto-completion and a few other handy tools.</p>
<blockquote>
<p><strong>Tip</strong>: Use <code>Ctrl-.</code> (Windows, or <code>Cmd-.</code> on macOS) to bring up VS Code suggestions, such as automatic imports. Note that you may have to save after the fix is applied to for any errors or warnings to be updated.</p>
</blockquote>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-1">here</a>.</p>
</blockquote>
<h2 id="challenge"><a class="header" href="#challenge">Challenge</a></h2>
<p>Try creating some cubes and changing their <code>translation()</code>, <code>scale()</code>, and <code>rotation()</code> components.</p>
<blockquote>
<p><strong>Tip</strong>: You can refer to the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/basics/primitives/src/server.rs">primitives example</a> in the Ambient GitHub repository.</p>
<p><strong>Source</strong>: The complete code for this challenge can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-1-challenge">here</a>.</p>
</blockquote>
<h2 id="-chapter-2-player-character"><a class="header" href="#-chapter-2-player-character"><a href="tutorials/game/./2_player_character.html">⇾ Chapter 2: Player character</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-adding-a-player-character"><a class="header" href="#chapter-2-adding-a-player-character">Chapter 2: Adding a player character</a></h1>
<p>In this chapter, we’ll add a floor to the scene, and then a player character that can run around in the world.</p>
<h2 id="creating-a-floor"><a class="header" href="#creating-a-floor">Creating a floor</a></h2>
<p>First, remove all code within <code>fn main</code> in <code>server.rs</code>, and replace it with the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with(quad(), ())
    .with(scale(), Vec3::ONE * 10.0)
    .with(color(), vec4(1.0, 0.0, 0.0, 1.0))
    .with(plane_collider(), ())
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>This will create a basic ground plane for us. Note that you will have also removed the camera, so you will not be able to see the plane yet. That’s normal!</p>
<blockquote>
<p><strong>Tip</strong>: When you save the file, the components are likely to have red squiggly lines under the components; that’s because they haven’t been imported yet. Click one of them, then hit <code>Ctrl-.</code> (or <code>Cmd-.</code> on macOS) and choose “Import …”.</p>
</blockquote>
<blockquote>
<p><strong>In-depth</strong>: Visit the <a href="https://docs.rs/ambient_api/latest/ambient_api/">full API reference docs</a> for details on the use of <code>Entity</code>, <code>.with</code> and <code>.spawn</code>.</p>
</blockquote>
<blockquote>
<p><strong>In-depth</strong>: Entities are the basic unit in an ECS. You can think of the ECS as a database, where <em>entities</em> are rows, and <em>components</em> (<code>quad</code>, <code>scale</code>, <code>color</code> and <code>plane_collider</code> in this case) are columns.</p>
<p>Components are always pure data; they don’t have any functionallity on their own. Instead, you typically write queries that read and write from the ECS (<em>systems</em>). <a href="tutorials/game/../../reference/ecs.html">Read more about the ECS here</a>.</p>
</blockquote>
<h2 id="adding-a-player-controller"><a class="header" href="#adding-a-player-controller">Adding a player controller</a></h2>
<p>Ambient supports dependencies, similar to Rust’s Cargo. To help you in your game-making journey, we’ve created several standard packages that you can use.</p>
<p>We’re going to use some of these packages to build our experience today. Start by adding the following to your <code>ambient.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
base_assets = { deployment = &quot;79plwEq1A0N3t0ExBOMTPM&quot; }
third_person_controller = { deployment = &quot;yV6nlkxj25cmkBhd4koe8&quot; }
character_animation = { deployment = &quot;4nLmHfcAlZkvWbK0NANMoC&quot; }
hide_cursor = { deployment = &quot;2ejmKJKgh6b4pTnwWPdv4s&quot; }
</code></pre>
<blockquote>
<p><strong>In-depth</strong>: To learn more about dependencies, check out the <a href="tutorials/game/../../reference/package.html#dependencies--dependencies">reference documentation</a>.</p>
</blockquote>
<p>Add the following code to <code>server.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_query(is_player()).bind(move |players| {
    for (id, _) in players {
        entity::add_components(
            id,
            Entity::new()
                .with_merge(ThirdPersonController::suggested())
                .with(model_from_url(), packages::base_assets::assets::url(&quot;Y Bot.fbx&quot;))
                .with(basic_character_animations(), id),
        );
    }
});
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: As before, you will need to import these components from their packages. You can use <code>Ctrl+.</code> (or <code>Cmd+.</code> on macOS) to do this.</p>
</blockquote>
<blockquote>
<p><strong>In-depth</strong>: A <code>spawn_query</code> runs when an entity with a specific set of components is seen for the first time (including when it is spawned).</p>
<p>Here, when a player spawns, we add a few components to that player to give it an animated model (<code>model_from_url</code>), use basic character animations (<code>basic_character_animations</code>) and to make it react to input with a camera that follows the character (<code>.with_merge(ThirdPersonController::suggested())</code>).</p>
<p><a href="tutorials/game/../../reference/ecs.html#systems">Read more about queries here</a>.</p>
</blockquote>
<p>Run your game by pressing <code>F5</code> in VS Code (or by typing <code>ambient run</code> in your terminal).</p>
<p>You should now see something like this on the screen:</p>
<p><img src="tutorials/game/fps_controller.png" alt="Player controller window" /></p>
<p>This character will respond to input, including moving around using WASD, jumping with Space, and looking around with the mouse.</p>
<p>Congratulations! You can now use this character as a base for the rest of the tutorial.</p>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-2">here</a>.</p>
</blockquote>
<blockquote>
<p><strong>Challenge</strong>: Add a <code>camera_distance</code> component to <code>-1.0</code> for a first-person-like experience.</p>
<p><strong>Source</strong>: The complete code for this challenge can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-2-challenge">here</a>.</p>
</blockquote>
<h2 id="-chapter-3-scene"><a class="header" href="#-chapter-3-scene"><a href="tutorials/game/./3_scene.html">⇾ Chapter 3: Scene</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-creating-the-scene"><a class="header" href="#chapter-3-creating-the-scene">Chapter 3: Creating the scene</a></h1>
<p>In this chapter, our goal is to create cube obstacles that the player has to walk around, and then we’ll rain bouncy balls down to add dynamism to the scene.</p>
<h2 id="adding-some-obstacles"><a class="header" href="#adding-some-obstacles">Adding some obstacles</a></h2>
<p>Let’s add some basic obstacles to your game. Add the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for _ in 0..30 {
    Entity::new()
        .with(cube(), ())
        .with(cube_collider(), Vec3::ONE)
        .with(
            translation(),
            (random::&lt;Vec2&gt;() * 20.0 - 10.0).extend(1.),
        )
        .spawn();
}
<span class="boring">}
</span></code></pre></pre>
<p>This code will spawn 30 cubes with random positions. Try running it!</p>
<blockquote>
<p><strong>In-depth</strong>: A <code>cube_collider</code> is one of the basic physics primitives. For more information, consult <a href="tutorials/game/../../reference/physics.html">the reference documentation on physics</a>, or try the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/physics/basics">physics example</a>.</p>
</blockquote>
<blockquote>
<p><strong>Challenge</strong>: <code>Entity::spawn</code> will return an <code>EntityId</code>. Try using <a href="https://docs.ambient.run/nightly/ambient_api/entity/fn.set_component.html"><code>set_component</code></a> to set the <code>rotation</code> of the cubes.</p>
</blockquote>
<p>It should look something like this:</p>
<p><img src="tutorials/game/scene.png" alt="Scene" /></p>
<h2 id="creating-a-rain-of-bouncy-balls"><a class="header" href="#creating-a-rain-of-bouncy-balls">Creating a rain of bouncy balls</a></h2>
<p>We can also spawn some interactive physics elements. Add the following to make it rain bouncy balls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixed_rate_tick(Duration::from_secs_f32(0.5), |_| {
    Entity::new()
        .with_merge(Sphere::suggested())
        .with_merge(Transformable::suggested())
        .with(scale(), Vec3::ONE * 0.2)
        .with(
            translation(),
            Vec3::X * 10. + (random::&lt;Vec2&gt;() * 2.0 - 1.0).extend(10.),
        )
        .with(sphere_collider(), 0.5)
        .with(dynamic(), true)
        .spawn();
});
<span class="boring">}
</span></code></pre></pre>
<p>This code will spawn a bouncy ball at a semi-random position each frame, where <code>Sphere</code> and <code>Transformable</code> are <a href="tutorials/game/../../reference/ecs.html#concepts">concepts</a> that provide the components required for a sphere that can be moved around.</p>
<blockquote>
<p><strong>In-depth</strong>: Here, we’re using a <code>Frame</code> message, which is sent by the runtime each frame. Learn more about messages in <a href="tutorials/game/../../reference/messages.html">the reference documentation</a>.</p>
</blockquote>
<p>Try running this. You should see a rain of bouncy balls now!</p>
<p><img src="tutorials/game/bouncy.png" alt="Bouncy balls" /></p>
<p>However, there’s quite a big problem: the bouncy balls never expire, so the world keeps filling up. Let’s fix that.</p>
<p>To begin with, we’re going to add this to the <code>ambient.toml</code>:</p>
<pre><code class="language-toml">[components]
bouncy_created = { type = &quot;Duration&quot; }
</code></pre>
<blockquote>
<p><strong>In-depth</strong>: Here, we’re defining a custom component. For more information on how component definitions work, as well as what they’re capable of, check out <a href="tutorials/game/../../reference/ecs.html#components">the reference documentation</a>.</p>
</blockquote>
<p>Next, we’re going to add the component to the bouncy balls. The <code>with</code> line needs to be placed before the <code>spawn</code> function, like so:</p>
<pre><code class="language-diff">.with(sphere_collider(), 0.5)
.with(dynamic(), true)
+ .with(bouncy_created(), game_time())
.spawn();
</code></pre>
<blockquote>
<p><strong>In-depth</strong>: Components are added in the order that you specify them, so it’s possible to override an earlier component with a later one. In this case, it doesn’t matter where you place the <code>bouncy_created</code> component as long as it’s prior to the entity being spawned.</p>
</blockquote>
<p>Finally, add this code at the end of your <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>query(bouncy_created()).each_frame(|entities| {
    for (id, created) in entities {
        if (game_time() - created).as_secs_f32() &gt; 5.0 {
            entity::despawn(id);
        }
    }
});
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>In-depth</strong>: Here, we see a query which runs every frame. It grabs all entities with the <code>bouncy_created</code> component and removes all components that are older than 5 seconds.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: Ambient offers a <code>remove_at_game_time</code> component that will do this for you, but we’re using this as an example of how to write a component definition and query. As an example of how you would use <code>remove_at_game_time</code>, you can replace the above code with the following:</p>
<pre><code class="language-diff">.with(sphere_collider(), 0.5)
.with(dynamic(), true)
+ .with(remove_at_game_time(), game_time() + Duration::from_secs(5))
.spawn();
</code></pre>
</blockquote>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-3">here</a>.</p>
</blockquote>
<h2 id="-chapter-4-player-interaction"><a class="header" href="#-chapter-4-player-interaction"><a href="tutorials/game/./4_player_interaction.html">⇾ Chapter 4: Player interaction</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-player-interaction"><a class="header" href="#chapter-4-player-interaction">Chapter 4: Player interaction</a></h1>
<p>It wouldn’t be much of a game if we didn’t have some player interaction though! Let’s add that.</p>
<h2 id="a-simple-paint-interaction"><a class="header" href="#a-simple-paint-interaction">A simple paint interaction</a></h2>
<p>First, we’ll add a <code>Paint</code> message to our <code>ambient.toml</code>:</p>
<pre><code class="language-toml">[message.Paint]
fields = { ray_origin = &quot;Vec3&quot;, ray_dir = &quot;Vec3&quot; }
</code></pre>
<blockquote>
<p><strong>In-depth</strong>: Read more about defining your own messages in <a href="tutorials/game/../../reference/messages.html">the reference documentation</a>.</p>
</blockquote>
<p>Next, we’ll add some code to the <strong><code>client.rs</code></strong> (for the first time in this tutorial!):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixed_rate_tick(Duration::from_millis(20), move |_| {
    let Some(camera_id) = camera::get_active() else {
        return;
    };

    let input = input::get();
    if input.keys.contains(&amp;KeyCode::Q) {
        let ray = camera::clip_position_to_world_ray(camera_id, Vec2::ZERO);

        Paint {
            ray_origin: ray.origin,
            ray_dir: ray.dir,
        }
        .send_server_unreliable();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>This code runs every 20 milliseconds, gets the active camera (and does nothing if it can’t), then checks if the <code>Q</code> key is pressed. If it is, it sends a <code>Paint</code> message to the server with the information required to perform a raycast to determine where to paint. The <code>fixed_rate_tick</code> is used to ensure that we don’t spam the server with messages on high frame rates.</p>
<blockquote>
<p><strong>In-depth</strong>: For a more detailed example of how to use screen rays, see <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/intermediate/screen_ray">the <code>screen_ray</code> example</a>.</p>
</blockquote>
<p>Let’s add this to our <code>server.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Paint::subscribe(|ctx, msg| {
    if ctx.client_user_id().is_none() {
        return;
    }

    let Some(hit) = physics::raycast_first(msg.ray_origin, msg.ray_dir) else {
        return;
    };

    Entity::new()
        .with(cube(), ())
        .with(translation(), hit.position)
        .with(scale(), Vec3::ONE * 0.1)
        .with(color(), vec4(0., 1., 0., 1.))
        .spawn();
});
<span class="boring">}
</span></code></pre></pre>
<p>This code will listen for messages. For each message, it will ensure that the message came from the client and then perform a raycast; if it hits something, it will spawn a green cube at the hit position.</p>
<p>When you run it, you should now be able to “paint” by holding/pressing <code>Q</code>:</p>
<p><img src="tutorials/game/paint.png" alt="Paint" /></p>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-4">here</a>.</p>
</blockquote>
<h2 id="-chapter-5-models"><a class="header" href="#-chapter-5-models"><a href="tutorials/game/./5_models.html">⇾ Chapter 5: Models</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-working-with-models"><a class="header" href="#chapter-5-working-with-models">Chapter 5: Working with models</a></h1>
<p>Games typically don’t just use cubes and spheres. Instead, they use 3D models. In this chapter, we’ll learn how to load and use 3D models in Ambient.</p>
<p>Let’s download <a href="https://github.com/KhronosGroup/glTF-Sample-Models/blob/master/2.0/AntiqueCamera/glTF-Binary/AntiqueCamera.glb">this free sample model from the official glTF sample repository</a>.</p>
<p>Click the little download icon to the right to download it.</p>
<p>Next, create a folder named <code>assets</code> in your project, and add the file to that folder (see <a href="tutorials/game/./1_package.html#package-structure">package structure</a>).</p>
<p>Create a file called <code>pipeline.toml</code> in the <code>assets</code> folder, with the following content:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
sources = [&quot;*.glb&quot;]
</code></pre>
<p>Note that this should <strong>not</strong> go in your <code>ambient.toml</code>. Pipelines are separate and are folder-specific.</p>
<blockquote>
<p><strong>In-depth</strong>: To learn more about how asset pipelines work, consult <a href="tutorials/game/../../reference/asset_pipeline.html">the reference documentation</a>.</p>
</blockquote>
<p>Finally, let’s use the model. In our <code>server.rs</code>, add the following lines:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(Transformable {
        local_to_world: Default::default(),
        optional: TransformableOptional {
            scale: Some(Vec3::ONE * 0.3),
            ..Default::default()
        },
    })
    .with(model_from_url(), packages::this::assets::url(&quot;AntiqueCamera.glb&quot;))
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>This creates a new entity with the <code>AntiqueCamera</code> model. This model will be loaded in on the client.</p>
<p>You should now see something like this:</p>
<p><img src="tutorials/game/model.png" alt="Model" /></p>
<p>Great! We’ve learned how to load models into Ambient.</p>
<blockquote>
<p><strong>Tip</strong>: Use <code>prefab_from_url</code> instead of <code>model_from_url</code> if you also want to include a collider.</p>
<p>This instantiates a prefab for the model that includes a collider. However, note that the antique camera here does not have a collider and you will need to consider adding a collider through the primitive colliders or through another source.</p>
<p>See <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/physics/basics">the physics example</a>.</p>
</blockquote>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-5">here</a>.</p>
</blockquote>
<h2 id="-chapter-6-ui"><a class="header" href="#-chapter-6-ui"><a href="tutorials/game/./6_ui.html"> ⇾ Chapter 6: UI</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-user-interface-ui"><a class="header" href="#chapter-6-user-interface-ui">Chapter 6: User interface (UI)</a></h1>
<p>Many games rely on showing some kind of UI on top of the 3D game, so let’s try adding some basic UI to our game.</p>
<h2 id="showing-the-players-position"><a class="header" href="#showing-the-players-position">Showing the player’s position</a></h2>
<p>Switch to <code>client.rs</code>, and add the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[element_component]
fn PlayerPosition(hooks: &amp;mut Hooks) -&gt; Element {
    let pos = use_entity_component(hooks, player::get_local(), translation());
    Text::el(format!(&quot;Player position: {}&quot;, pos.unwrap_or_default()))
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>In-depth</strong>: UI in Ambient is loosely inspired by React. See <a href="tutorials/game/../../reference/ui.html">the UI reference documentation</a> for more information.</p>
</blockquote>
<blockquote>
<p><strong>Tip</strong>: See <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui">the UI examples</a> to learn how to use layout, buttons, editors and much more.</p>
</blockquote>
<p>And then add this to the <code>main</code> function in <code>client.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PlayerPosition.el().spawn_interactive();
<span class="boring">}
</span></code></pre></pre>
<p>You should now see something like this:</p>
<p><img src="tutorials/game/ui.png" alt="UI" /></p>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-6">here</a>.</p>
</blockquote>
<blockquote>
<p><strong>Challenge</strong>: Try adding a <a href="https://docs.ambient.run/nightly/ambient_api/prelude/struct.Button.html"><code>Button</code></a>, which sends a message to the server and teleports the player somewhere else when clicked. You may find <a href="tutorials/game/./4_player_interaction.html">Chapter 4</a>, the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/ui/button/src/client.rs">button example</a> and the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui/todo">todo example</a> useful.</p>
<p><strong>Source</strong>: The complete code for this challenge can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-6-challenge">here</a>.</p>
</blockquote>
<h2 id="-chapter-7-deploying"><a class="header" href="#-chapter-7-deploying"><a href="tutorials/game/./7_deploying.html">⇾ Chapter 7: Deploying</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-publishing-your-game"><a class="header" href="#chapter-7-publishing-your-game">Chapter 7: Publishing your game</a></h1>
<p>So you’ve got a small game built and want to share it with a friend. How do we do that?</p>
<p>Easy! All you need to do is run:</p>
<pre><code>ambient deploy
</code></pre>
<blockquote>
<p><strong>Note</strong>: The first time you run it, it will raise an error that will tell you to create your user account and to generate and use an API token. Follow the instructions in the error message to do so.</p>
</blockquote>
<p>Once your game is deployed, you can just go to the web URL provided and play it from there. You can send the URL
to a friend, and they can join you there as well!</p>
<p>If a <code>screenshot.png</code> is present in the package’s directory, it will be used as the game’s thumbnail on the Ambient website. We recommend you include one.</p>
<blockquote>
<p><strong>Tip</strong>: Deploying with <code>ambient deploy</code> will deploy to the Ambient servers. For more deployment options, including your own game servers, see the <a href="tutorials/game/../../reference/distributing.html">reference documentation on distribution</a>.</p>
</blockquote>
<h2 id="-chapter-8-modding"><a class="header" href="#-chapter-8-modding"><a href="tutorials/game/./8_modding.html">⇾ Chapter 8: Modding</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8-modding"><a class="header" href="#chapter-8-modding">Chapter 8: Modding</a></h1>
<p>In this final chapter, we’ll look at modding. All games are moddable by default with Ambient.</p>
<h2 id="adding-the-mod-manager-ui"><a class="header" href="#adding-the-mod-manager-ui">Adding the Mod Manager UI</a></h2>
<p>We’ll start by adding the Mod Manager UI package to your game, so that you can list and enable mods for your game. Start by adding the following to your <code>ambient.toml</code>’s dependencies:</p>
<pre><code class="language-toml">package_manager = { deployment = &quot;2nkcSe373rR3IdVwxkKHkj&quot; }
</code></pre>
<p>(To find the latest deployment, visit the page for <a href="https://ambient.run/packages/hr4pxz7kfhzgimicoyh65ydel3aehuhk">the package mananger</a>.)</p>
<p>Then add this to the top of your <code>server.rs</code>’s main function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>entity::add_component(
    package_manager::entity(),
    package_manager::components::mod_manager_for(),
    packages::this::entity(),
);
<span class="boring">}
</span></code></pre></pre>
<p>Launch your game, and then press F4 to open the Mod Manager. From here, you can enable and disable mods. As your package is brand-new, there won’t be any mods available yet. Let’s fix that.</p>
<blockquote>
<p><strong>Note</strong>: You can build your own Mod Manager UI if you want to. You can see the source code for the
default one <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/packages/tools/package_manager">here</a>.</p>
</blockquote>
<h2 id="creating-a-mod"><a class="header" href="#creating-a-mod">Creating a mod</a></h2>
<p>To create a mod for your game, run <code>ambient new my_mod --rust empty</code>, then update the <code>ambient.toml</code> of the mod with this:</p>
<pre><code class="language-toml"># Note: Add this field, or replace it if it already exists, making sure to update the ID:
content = { type = &quot;Mod&quot;, for_playables = [&quot;the_id_of_your_game_from_its_ambient_toml&quot;] }

[dependencies]
# Note: This line will make it possible to run the mod locally, as it will pull in your game as a dependency.
# Replace LATEST_DEPLOYMENT_ID with the latest deployment ID of your game, which can be found on the game's page.
# When you want to deploy the mod, comment this line out first
my_game = { deployment = &quot;LATEST_DEPLOYMENT_ID&quot; }
</code></pre>
<p>You can now edit and run the code in <code>src/</code>, as per usual. Once you’re happy with your mod, you can deploy it with <code>ambient deploy</code>, just like with the game. Providing a <code>screenshot.png</code> is recommended to make sure your mod stands out.</p>
<p>Remember to comment out the <code>my_game = ..</code> line before deploying.</p>
<p>This concludes the Ambient tutorial. Thanks for following along! If you have any questions, feel free to <a href="https://discord.gg/ambient">join our Discord server</a> and ask away.</p>
<blockquote>
<p><strong>Source</strong>: The complete code for this chapter can be found <a href="https://github.com/AmbientRun/TutorialProject/tree/chapter-8">here</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-content-for-your-game"><a class="header" href="#getting-content-for-your-game">Getting content for your game</a></h1>
<p>Content, including assets, is a key part of any game. For a polished game, you will likely want to
build your own content. However, for prototyping, or for a game jam, you may want to use existing
content.</p>
<p>This page lists some sources of content that you can use in your game. Some of these may have already
been uploaded as packages to the platform; check there first before importing the content yourself.</p>
<p>For details on how to import the content, see <a href="reference/./asset_pipeline.html">asset pipeline</a>.</p>
<h2 id="characters-and-animations"><a class="header" href="#characters-and-animations">Characters and animations</a></h2>
<ul>
<li><a href="https://www.mixamo.com">Mixamo</a>: Free characters and animations.</li>
<li><a href="https://www.rokoko.com/free-resources">Rokoko</a>: Free character animation assets.</li>
</ul>
<h2 id="models"><a class="header" href="#models">Models</a></h2>
<ul>
<li><a href="https://opengameart.org/">OpenGameArt</a>: Creative commons licensed.</li>
<li><a href="https://www.kenney.nl/assets/category:3D">Kenney</a>: Creative commons licensed.</li>
<li><a href="https://assetstore.unity.com/">Unity asset store</a>: Lots of content. The Ambient asset pipeline supports importing Unity models. However, ensure that the license allows you to use the content in your game.</li>
<li><a href="https://quixel.com/">Quixel</a>: Realistic scanned models. The asset pipeline supports importing Quixel models. However, ensure that the license allows you to use the content in your game.</li>
<li><a href="https://sketchfab.com/">Sketchfab</a>: Many models.</li>
<li><a href="https://polyhaven.com/">Polyhaven</a>: The Public 3D Asset Library.</li>
<li><a href="https://github.com/KhronosGroup/glTF-Sample-Models">Official GLTF sample models</a></li>
</ul>
<h2 id="materials--textures"><a class="header" href="#materials--textures">Materials &amp; Textures</a></h2>
<ul>
<li><a href="https://ambientcg.com/">Ambientcg.com</a>: Many materials.</li>
<li><a href="https://gametextures.com/freebies">Gametextures</a>: Signup to get some freebie textures.</li>
</ul>
<h2 id="audio"><a class="header" href="#audio">Audio</a></h2>
<ul>
<li><a href="https://freesound.org/">Freesound.org</a>: Lots of sounds, including both recordings and synthesized sounds.</li>
<li><a href="https://www.bfxr.net/">8bit Sound Generator</a>: You have full rights to all sounds made with bfxr, and are free to use them for any purposes, commercial or otherwise.</li>
<li><a href="https://www.boomlibrary.com/">Boomlibrary</a>: Paid. Lots of game sounds and packages.</li>
<li><a href="https://www.weloveindies.com/en">WeLoveIndies.com</a>: Paid. Lots of game sounds and music.</li>
</ul>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<ul>
<li><a href="https://github.com/madjin/awesome-cc0">awesome-cc0</a>: A list of Creative Commons 0 (CC0) licensed assets. These assets can be used for any purpose, including commercially.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<h2 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate system</a></h2>
<p>By default, Ambient uses a right-handed coordinate system for normalized device coordinates (NDC) with <code>z</code> from 1 to 0 (i.e. reverse-z with the near plane at <code>z=1</code>, and the far plane at <code>z=0</code>).</p>
<p>For world coordinates, it uses a left-handed system. We consider <code>x</code> to be right, <code>y</code> to be back, and <code>z</code> to be up (same as Unreal). Note that this means forward is <code>-y</code>, not <code>+y</code> or <code>+z</code>!</p>
<p>This means that the default camera without any transformation is lying on its stomach and facing downwards.</p>
<pre><code>NDC:
   y
   |
   |
   0 ---&gt; x
 /
z (coming out of the screen)

World:
  z (up)
  |
  0 --- x (right)
 /
y
</code></pre>
<p>WebGPU uses positive-<code>y</code> as up in its NDC, and <code>z</code> from 0 to 1 (https://gpuweb.github.io/gpuweb/#coordinate-systems) - that is, it is left-handed.</p>
<p>Freya Holmér has produced an overview of which programs use which coordinate systems, which can be found <a href="https://twitter.com/freyaholmer/status/1325556229410861056">here</a>.</p>
<p>For more information on our use of reverse-z, consult the following links:</p>
<ul>
<li><a href="https://developer.nvidia.com/content/depth-precision-visualized">https://developer.nvidia.com/content/depth-precision-visualized</a></li>
<li><a href="https://www.danielecarbone.com/reverse-depth-buffer-in-opengl/">https://www.danielecarbone.com/reverse-depth-buffer-in-opengl/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package"><a class="header" href="#package">Package</a></h1>
<p>All Ambient packages must have an <code>ambient.toml</code> manifest that describes their functionality. This format is in flux, but is inspired by Rust’s <code>Cargo.toml</code>.</p>
<p>Next to the <code>ambient.toml</code>, other files may be present. A <code>screenshot.png</code> can be used to provide a thumbnail for the package on the Ambient website. A <code>README.md</code> can be used to provide a description of the package on the Ambient website.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<ul>
<li><code>SnakeCaseIdentifier</code>s are snake-case ASCII identifiers (as a string)</li>
<li><code>PascalCaseIdentifier</code>s are PascalCase ASCII identifiers (as a string)</li>
<li><code>Identifiers</code> are either a <code>SnakeCaseIdentifier</code> or a <code>PascalCaseIdentifier</code> based on context</li>
<li><code>ItemPath</code>s are a double-colon-separated list of <code>SnakeCaseIdentifier</code>s followed by a single <code>Identifier</code>. For example, <code>my_package</code> is an <code>Identifier</code>, and <code>my_package::my_component</code> is an <code>ItemPath</code>.</li>
<li>See <a href="reference/package.html#valuetype"><code>ValueType</code></a> for a description of the types that can be used in Ambient.</li>
</ul>
<h3 id="package--package"><a class="header" href="#package--package">Package / <code>[package]</code></a></h3>
<p>The <code>package</code> section contains metadata about the package itself, such as its name and version.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>id</code></td><td><code>SnakeCaseIdentifier</code></td><td>✅</td><td>The package’s ID. Autogenerated by Ambient. Do not attempt to specify your own ID.</td></tr>
<tr><td><code>name</code></td><td><code>String</code></td><td>✅</td><td>A human-readable name for the package.</td></tr>
<tr><td><code>version</code></td><td><code>String</code></td><td>✅</td><td>The package’s version, in <code>(major, minor, patch)</code> format. Semantically versioned.</td></tr>
<tr><td><code>content</code></td><td><code>PackageContent</code></td><td>✅</td><td>A description of the content of this Package. See below.</td></tr>
<tr><td><code>ambient_version</code></td><td><code>String</code></td><td>✅</td><td>The version of Ambient this package is intended to be used with.</td></tr>
<tr><td><code>authors</code></td><td><code>String[]</code></td><td></td><td>The authors of the package.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td></td><td>A human-readable description of the package.</td></tr>
<tr><td><code>repository</code></td><td><code>String</code></td><td></td><td>Where the source code for this package can be found.</td></tr>
<tr><td><code>public</code></td><td><code>Bool</code></td><td></td><td>Indicates if this package will be publicly available when deployed. Defaults to true.</td></tr>
</tbody></table>
<h4 id="packagecontent"><a class="header" href="#packagecontent"><code>PackageContent</code></a></h4>
<p>These are the valid configurations for package content:</p>
<pre><code class="language-toml"># A Playable is anything that can be run as an application; i.e. games, examples, applications etc.
content = { type = &quot;Playable&quot; }
content = { type = &quot;Playable&quot;, example = true } # example defaults to false

# Assets are things you can use as a dependency in your package
content = { type = &quot;Asset&quot;, models = true, textures = true } # Contains models and textures
# These are the valid asset types:
#
#   models
#   animations
#   textures
#   materials
#   audio
#   fonts
#   code
#   schema
#
# You can use any combination of them

# Tools are things you can use to develop your package
content = { type = &quot;Tool&quot; }

# Mods are extension to Playables
content = { type = &quot;Mod&quot;, for_playables = [&quot;i3terk32jw&quot;] }
</code></pre>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><code class="language-toml">#
# The package section describes all package metadata.
#
[package]
id = &quot;d563xtcr72ovuuhfkvsgag6z3wiy5jwr&quot;
name = &quot;My Cool Package&quot;
version = &quot;0.0.1&quot;
content = { type = &quot;Asset&quot;, code = true }
ambient_version = &quot;0.3.0&quot;

# The following are optional:
# authors = [&quot;Cool Cat&quot;]
# description = &quot;A sample package that's the coolest thing ever.&quot;
# repository = &quot;https://my-cool-forge.io/my-cool-package&quot;
# public = true
</code></pre>
<h3 id="build--build"><a class="header" href="#build--build">Build / <code>[build]</code></a></h3>
<p>The build section contains settings related to building the package.</p>
<h4 id="rust-settings--buildrust"><a class="header" href="#rust-settings--buildrust">Rust Settings / <code>[build.rust]</code></a></h4>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>feature-multibuild</code></td><td><code>String[]</code></td><td></td><td>An array of strings defining the Rust features to be used when building the package. This is used to build the same code for both client and server.<br /><br /><code>cargo build</code> will be run with each of these features to produce a separate WASM binary, which is then componentized and copied into a folder of the corresponding name in <code>build/</code>.<br /><br />Client and server are built by default (e.g. <code>[&quot;client&quot;, &quot;server&quot;]</code>); this is exposed so that you can disable building one side entirely if required.</td></tr>
</tbody></table>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><code class="language-toml">[build.rust]
feature-multibuild = [&quot;client&quot;, &quot;server&quot;]
</code></pre>
<h3 id="components--components"><a class="header" href="#components--components">Components / <code>[components]</code></a></h3>
<p>The <code>components</code> section contains custom components defined by the package. Components are used to store data on entities.</p>
<p>This is a TOML table, where the keys are the component IDs (<code>SnakeCaseIdentifier</code>), and the values are the component definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ValueType</code></td><td>✅</td><td>The type of the component.</td></tr>
<tr><td><code>name</code></td><td><code>String</code></td><td></td><td>A human-readable name for the component.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td></td><td>A human-readable description of the component.</td></tr>
<tr><td><code>attributes</code></td><td><code>ComponentAttribute[]</code></td><td></td><td>An array of attributes for the component.</td></tr>
</tbody></table>
<p>A <code>ComponentAttribute</code> is a string that can be one of the following:</p>
<ul>
<li><code>Debuggable</code>: this component can have its debug value printed, especially in ECS dumps</li>
<li><code>Networked</code>: this component is networked</li>
<li><code>Resource</code>: this component will only ever be used as a resource; will error if attached to an entity</li>
<li><code>MaybeResource</code>: this component can be used as a resource or as a component; necessary if treating this component as a resource</li>
<li><code>Store</code>: this component’s value should be persisted when the world is saved</li>
</ul>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><code class="language-toml">[components]
# Inline tables can be used.
cool_component = { type = &quot;I32&quot;, name = &quot;Cool Component&quot;, description = &quot;A cool component&quot;, attributes = [&quot;Debuggable&quot;] }

# Explicit tables can also be used.
[components.cool_component2]
type = &quot;I32&quot;
name = &quot;Cool Component 2&quot;
description = &quot;A cool component 2&quot;
attributes = [&quot;Debuggable&quot;]
</code></pre>
<h3 id="concepts--concepts"><a class="header" href="#concepts--concepts">Concepts / <code>[concepts]</code></a></h3>
<p>The <code>concepts</code> section contains custom concepts defined by the package. Concepts are used to define a set of components that can be attached to an entity.</p>
<p>This is a TOML table, where the keys are the concept IDs (<code>CamelCaseIdentifier</code>), and the values are the concept definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td></td><td>A human-readable name for the concept.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td></td><td>A human-readable description of the concept.</td></tr>
<tr><td><code>extends</code></td><td><code>String[]</code></td><td></td><td>An array of concepts to extend. Must be defined in this package manifest.</td></tr>
<tr><td><code>components.required</code></td><td><code>Map&lt;ItemPath, ConceptValue&gt;</code></td><td>✅</td><td>An object containing the required components for this concept, and any associated information about the use of the component in this concept (see below).</td></tr>
<tr><td><code>components.optional</code></td><td><code>Map&lt;ItemPath, ConceptValue&gt;</code></td><td></td><td>An object containing the optional components for this concept, and any associated information about the use of the component in this concept (see below). These components do not need to be specified to satisfy a concept, but may provide additional control or information if available.</td></tr>
</tbody></table>
<p>The <code>components</code> is an object where the keys are <code>ItemPath</code>s of components defined in the package manifest, and the values are <code>ConceptValue</code>s.</p>
<p><code>ConceptValue</code>s are a TOML table with the following properties:</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>description</code></td><td><code>String</code></td><td></td><td>A human-readable description of the component in the context of the concept, which may be different to the component’s description.</td></tr>
<tr><td><code>suggested</code></td><td><code>toml::Value</code></td><td></td><td>If specified, the suggested value for this component in this concept. This is merely a suggestion, but must match the type of the component.<br /><br /><code>Mat4</code> and <code>Quat</code> support <code>Identity</code> as a string, which will use the relevant identity value for that type.<br /><br /><code>F32</code> and <code>F64</code> support <code>PI</code>, <code>FRAC_PI_2</code>, <code>-PI</code>, and <code>-FRAC_PI_2</code> as string values, which correspond to pi (~3.14), half-pi (~1.57), and negative versions respectively.</td></tr>
</tbody></table>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<pre><code class="language-toml">[concepts.Concept1]
name = &quot;Concept 1&quot;
description = &quot;The best&quot;
[concepts.Concept1.components.required]
cool_component = {}

# A concept that extends `concept1` and has both `cool_component` and `cool_component2`.
[concepts.Concept2]
extends = [&quot;Concept1&quot;]

[concepts.Concept2.components.required]
cool_component2 = { suggested = 42 }

[concepts.Concept2.components.optional]
cool_component3 = { suggested = 42 }
</code></pre>
<h3 id="messages--messages"><a class="header" href="#messages--messages">Messages / <code>[messages]</code></a></h3>
<p>The <code>messages</code> section contains custom messages defined by the package. Messages are used to communicate between client and server, or between packages/modules on the same side.</p>
<p>For an example of how to use messages, see the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/intermediate/messaging">messaging example</a>.</p>
<p>This is a TOML table, where the keys are the message IDs (<code>PascalCaseIdentifier</code>), and the values are the message definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>description</code></td><td><code>String</code></td><td></td><td>A human-readable description of the message.</td></tr>
<tr><td><code>fields</code></td><td><code>Map&lt;SnakeCaseIdentifier, ValueType&gt;</code></td><td>✅</td><td>An object containing the fields and their types. Must be one of the types supported for components.</td></tr>
</tbody></table>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<pre><code class="language-toml">[messages.Input]
description = &quot;Describes the input state of the player.&quot;
[messages.Input.fields]
# Each field in the message must have a type.
direction = &quot;Vec2&quot;
mouse_delta_x = &quot;F32&quot;
</code></pre>
<h3 id="enums--enums"><a class="header" href="#enums--enums">Enums / <code>[enums]</code></a></h3>
<p>The <code>enums</code> section contains custom enums defined by the package. Enums are used to define a closed set of values.</p>
<p>This is a TOML table, where the keys are the package IDs (<code>PascalCaseIdentifier</code>), and the values are the package definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>description</code></td><td><code>String</code></td><td></td><td>A human-readable description of the enum.</td></tr>
<tr><td><code>members</code></td><td><code>Map&lt;PascalCaseIdentifier, String&gt;</code></td><td>✅</td><td>An object containing the members and their descriptions. The description can be empty.</td></tr>
</tbody></table>
<h4 id="example-5"><a class="header" href="#example-5">Example</a></h4>
<pre><code class="language-toml">[enums.CakeBakeState]
description = &quot;Describes the state of a cake bake.&quot;
[enums.CakeBakeState.members]
GatheringIngredients = &quot;Gathering ingredients&quot;
MixingIngredients = &quot;Mixing ingredients&quot;
Baking = &quot;Baking&quot;
Cooling = &quot;Cooling&quot;
Decorating = &quot;Decorating&quot;
Done = &quot;Done&quot;
</code></pre>
<h3 id="includes--includes"><a class="header" href="#includes--includes">Includes / <code>[includes]</code></a></h3>
<p>The <code>includes</code> section contains a list of manifests to pull in under a given name. This is useful for splitting up a package into multiple files.</p>
<p>This is a TOML table, where the keys are the name that you want to access this include by (<code>SnakeCaseIdentifier</code>), and the location of the package manifest is the value.</p>
<h4 id="example-6"><a class="header" href="#example-6">Example</a></h4>
<pre><code class="language-toml">[includes]
graphics = &quot;graphics/ambient.toml&quot;
</code></pre>
<h3 id="dependencies--dependencies"><a class="header" href="#dependencies--dependencies">Dependencies / <code>[dependencies]</code></a></h3>
<p>The <code>dependencies</code> section contains a list of package IDs that this package depends on.</p>
<p>Depending on another package gives you access to its items, including its components, concepts, messages, and enums. It can also provide access to any assets that the package has.</p>
<p>This is a TOML table, where the keys are the name that you want to access this package by (<code>SnakeCaseIdentifier</code>), and the location of the package is the value.</p>
<p>To access an item from a package, use the following syntax: <code>import_name::item_id</code>. For example, if you have a package imported with the name <code>the_basics</code> and an enum with ID <code>BasicEnum</code>, you can access it with <code>the_basics::BasicEnum</code>.</p>
<p>At least one of <code>path</code> or <code>deployment</code> must be specified.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td><code>String</code></td><td>A relative path to the package to depend on.</td></tr>
<tr><td><code>deployment</code></td><td><code>String</code></td><td>The ID of a deployed package to depend on.</td></tr>
<tr><td><code>enabled</code></td><td><code>bool</code></td><td>Control whether or not logic associated with this package should be enabled on load. Enabled by default.</td></tr>
</tbody></table>
<p>For an example of how to use dependencies, see the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/intermediate/dependencies">dependencies example</a>.</p>
<h4 id="example-7"><a class="header" href="#example-7">Example</a></h4>
<pre><code class="language-toml">[dependencies]
the_basics = { path = &quot;../basics&quot; }

[components]
my_component = { type = &quot;the_basics::BasicEnum&quot; }
</code></pre>
<h3 id="runtime-access-to-packages"><a class="header" href="#runtime-access-to-packages">Runtime access to packages</a></h3>
<p>Packages are represented as entities within the ECS, with their metadata being stored as components. This means that you can access the metadata of a package at runtime. To do so, you can use the <code>entity()</code> function inside the generated Rust code for the package:</p>
<pre><pre class="playground"><code class="language-rust">use ambient_api::prelude::*;

#[main]
fn main() {
    dbg!(entity::get_all_components(packages::this::entity()));
}
</code></pre></pre>
<p>Or by querying for entities that have the <code>is_package</code> component:</p>
<pre><pre class="playground"><code class="language-rust">use ambient_api::{
    core::package::components::{is_package, name},
    prelude::*,
};

#[main]
fn main() {
    let q = query((is_package(), name())).build();
    // List all packages and their names.
    dbg!(q.evaluate());
}
</code></pre></pre>
<h3 id="valuetype"><a class="header" href="#valuetype"><code>ValueType</code></a></h3>
<p>In Ambient, all typed values must have a type that belongs to <code>ValueType</code>. This includes component types and message fields.</p>
<p>A <code>ValueType</code> is either:</p>
<ul>
<li>
<p>a string that can be one of the following primitive types:</p>
<ul>
<li><code>Bool</code>: a boolean value, true or false</li>
<li><code>Empty</code>: a component that has no value; most often used for tagging an entity</li>
<li><code>EntityId</code>: an entity ID</li>
<li><code>F32</code>: a 32-bit floating point value</li>
<li><code>F64</code>: a 64-bit floating point value</li>
<li><code>Mat4</code>: a 4x4 32-bit floating point matrix</li>
<li><code>Quat</code>: a 32-bit floating point quaternion</li>
<li><code>String</code>: a UTF-8 string</li>
<li><code>U8</code>: an 8-bit unsigned integer value</li>
<li><code>U16</code>: an 16-bit unsigned integer value</li>
<li><code>U32</code>: a 32-bit unsigned integer value</li>
<li><code>U64</code>: a 64-bit unsigned integer value</li>
<li><code>I8</code>: an 8-bit signed integer value</li>
<li><code>I16</code>: an 16-bit signed integer value</li>
<li><code>I32</code>: a 32-bit signed integer value</li>
<li><code>I64</code>: a 64-bit signed integer value</li>
<li><code>Uvec2</code>: a 2-element 32-bit unsigned integer vector</li>
<li><code>Uvec3</code>: a 3-element 32-bit unsigned integer vector</li>
<li><code>Uvec4</code>: a 4-element 32-bit unsigned integer vector</li>
<li><code>Ivec2</code>: a 2-element 32-bit signed integer vector</li>
<li><code>Ivec3</code>: a 3-element 32-bit signed integer vector</li>
<li><code>Ivec4</code>: a 4-element 32-bit signed integer vector</li>
<li><code>Vec2</code>: a 2-element 32-bit floating point vector</li>
<li><code>Vec3</code>: a 3-element 32-bit floating point vector</li>
<li><code>Vec4</code>: a 4-element 32-bit floating point vector</li>
<li><code>Duration</code>: A time span. Often used as a timestamp, in which case it designates the duration since Jan 1, 1970.</li>
</ul>
</li>
<li>
<p>a contained type of the form <code>{ type = &quot;Vec&quot;, element_type = ValueType }</code> or <code>{ type = &quot;Option&quot;, element_type = ValueType }</code></p>
<ul>
<li>Note that <code>Vec</code> and <code>Option</code> are the only supported container types, and <code>element_type</code> must be a primitive <code>ValueType</code> (that is, you cannot have nested contained types).</li>
</ul>
</li>
<li>
<p>a string that refers to an <code>enum</code> defined by a package; see <a href="reference/./package.html#enums--enums">Enums</a>.</p>
</li>
</ul>
<p>Note that <code>ValueType</code>s are not themselves values, but rather types of values. For example, <code>Vec2</code> is a <code>ValueType</code>, but <code>Vec2(1.0, 2.0)</code> is a value of type <code>Vec2</code>. Additionally, <code>ValueType</code>s from other packages can be referred to using <code>ItemPath</code>s: <code>my_package::my_component::MyType</code>.</p>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<p>All <code>.wasm</code> components in the <code>build/{client, server}</code> directory will be loaded for the given network side. The <code>.wasm</code> filenames must be snake-case ASCII identifiers, like the <code>id</code> in the manifest.</p>
<p>This means any <code>.wasm</code> which implements the Ambient <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/wit">WIT interface</a> and targets WASI snapshot 2 (or uses an adapter that targets WASI snapshot 2) should run within Ambient.</p>
<p>As a convenience for Rust users, Ambient will automatically build a <code>Cargo.toml</code> if present at the root of your package, as <code>wasm32-wasi</code> for the features specified in <code>build.rust.feature-multibuild</code> in <code>ambient.toml</code> (defaults to <code>client</code> and <code>server</code>).</p>
<p>The default new package template will create <code>client.rs</code> and <code>server.rs</code> files, with a <code>Cargo.toml</code> preconfigured with targets for both. The resulting WASM bytecode files are then converted to a <em>component</em> and placed in <code>build/{client, server}</code>.</p>
<p>The process it takes is equivalent to these commands:</p>
<pre><code class="language-sh">cd your_package
cargo build --target wasm32-wasi --features client
wasm-tools component new target/wasm32-wasi/debug/your_package_client.wasm -o build/client/your_package.wasm --adapt wasi_snapshot_preview1.command.wasm

cargo build --target wasm32-wasi --features server
wasm-tools component new target/wasm32-wasi/debug/your_package_server.wasm -o build/server/your_package.wasm --adapt wasi_snapshot_preview1.command.wasm
</code></pre>
<p>using <a href="https://github.com/bytecodealliance/wasm-tools">wasm-tools</a> and a bundled version of the <a href="https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasi-preview1-component-adapter">preview1-to-preview2 WASI adapter</a>.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust is a first-class language for Ambient packages. The default new package template will create <code>client.rs</code> and <code>server.rs</code> files, with a <code>Cargo.toml</code> preconfigured with targets for both.</p>
<p>The API provides a <code>#[main]</code> attribute macro that generates code to allow you to access the data and functionality of the packages known to your package. All packages, including your own, will be in the <code>packages</code> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity Component System (ECS)</a></h1>
<p>An entity component system (ECS) is an architectural pattern that is used in game development to organize the logic of a game. It is a data-oriented approach to programming, which means that it focuses on the data that is being processed, rather than the logic that is processing it.</p>
<p>The ECS pattern is based on three concepts: <em>entities</em>, <em>components</em>, and <em>systems</em>. Entities are the objects that exist in the game world. Components are the data that describe the entities. Systems are the logic that processes the components.</p>
<p>Conceptually, the ECS can be considered to be a database, where the entities are the rows, the components are the columns, and the systems are the queries. The ECS is designed to be fast and efficient, and is used in many modern game engines.</p>
<p>In addition to the three core concepts, Ambient also supports <em>concepts</em>, which are a way of defining a collection of components that correspond to some concept in the game world. For example, a <code>Player</code> concept might be defined as a collection of components that describe the player’s health, inventory, and position.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>Entities are the objects that exist in the game world. They consist of a unique identifier (an <code>EntityId</code>, which is 128 bits) and a set of components. Entities are created and destroyed dynamically during runtime.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Components are pieces of data that can be attached to entities. They store information like health, position, velocity, and more. Components are defined in the package manifest, and are attached to entities at runtime.</p>
<p>They are defined in the manifest (and not your codebase) so that other packages that depend on your package can use them when interacting with the ECS. Additionally, this means that component definitions are not tied to a specific language, and can be used in any language that supports the runtime.</p>
<p>For more detail on what components can be, see the <a href="reference/./package.html#components--components">package manifest reference</a>. Note that component types cannot be nested - you cannot have a component that is a <code>Vec</code> of <code>Vec</code>s.</p>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Components can have attributes that modify their behavior. These attributes are defined in the package manifest, and are used by the runtime to determine how to handle the component.</p>
<h4 id="debuggable"><a class="header" href="#debuggable"><code>Debuggable</code></a></h4>
<p>This component can have its debug value printed. This is most often used for ECS dumps, but can also be used for debugging purposes.</p>
<h4 id="networked"><a class="header" href="#networked"><code>Networked</code></a></h4>
<p>This component is networked to the client. This means that the component’s value will be sent to the client when the component is created, and whenever the component’s value changes.</p>
<p>Note that a component that is <code>Networked</code> on the client will <em>not</em> be networked to the server. Ambient’s ECS networking is strictly server to client; to send data from the client to the server, you must use <a href="reference/./package.html#messages--messages">messages</a>.</p>
<h4 id="resource"><a class="header" href="#resource"><code>Resource</code></a></h4>
<p>This component will only ever be attached to the <code>entity::resources()</code> entity, which is always present in the world. This is useful for storing global state that is not tied to a specific entity.</p>
<p>This component will error when attached to any other entity. Note that the resources entity is not networked; if you want networked global state, consider using <code>entity::synchronized_resources()</code>.</p>
<h4 id="mayberesource"><a class="header" href="#mayberesource"><code>MaybeResource</code></a></h4>
<p>This component can be used as either a resource or as a component. This is useful for components that are traditionally attached to entities, but are sometimes attached to the resource entity.</p>
<p>This is most commonly used for components that are used in the resources of a prefab to provide metadata about the prefab. It is unlikely you will need to interact with this directly as a user.</p>
<h4 id="store"><a class="header" href="#store"><code>Store</code></a></h4>
<p>This component’s value will be stored in the world file. This is useful for components that store persistent state, like the player’s inventory.</p>
<p>At present, Ambient does not support persistency. This functionality will be added in the future.</p>
<h2 id="systems"><a class="header" href="#systems">Systems</a></h2>
<p>Systems are the logic that processes the components. Ambient guest code cannot directly define systems; instead, they rely on queries that run every frame. These function identically to systems for now, but systems may be formally introduced in the future to allow for more advanced functionality, including automatic parallelism of the ECS.</p>
<p>Queries are powerful, and can be used to query for entities that have a specific component, or a specific set of components. At present, they are entirely structural, so they cannot be used to query for entities that have a specific value for a component.</p>
<p>There are three types of queries in Ambient at present: general queries, (de)spawn queries, and change queries.</p>
<p>General queries are the most common type of query. They are used to query for entities that have a specific set of components:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>query((player(), player_camera_ref(), translation(), rotation())).each_frame(move |players| {
    for (_, (_, camera_id, pos, rot)) in players {
        let forward = rot * Vec3::X;
        entity::set_component(camera_id, lookat_target(), pos);
        entity::set_component(camera_id, translation(), pos - forward * 4. + Vec3::Z * 2.);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Spawn queries are used to query for when specific components are added to entities (including the entire entity being spawned). They are useful for spawning entities when a player joins the game; for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_query(player()).bind(move |players| {
    // For each player joining, spawn a random colored box somewhere
    for _ in players {
        Entity::new()
            .with_merge(Transformable::suggested())
            .with(cube(), ())
            .with(translation(), rand::random())
            .with(color(), rand::random::&lt;Vec3&gt;().extend(1.0))
            .spawn();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Despawn queries are similar to spawn queries, but track the removal of components from entities (including the entire entity being despawned). They are useful for cleaning up entities when a player leaves the game; for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>despawn_query(user_id()).requires(player()).bind(move |players| {
    for (_, user_id) in players {
        println!(&quot;Player {user_id} left&quot;);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Finally, change queries are activated when one of the components they track change. Note that the components that are returned by the query are separate from the components that are tracked; this allows you to get more information about the entity than just the components that changed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>change_query((user_id(), health())).track_change(health()).requires(player()).bind(move |players| {
    for (_, (user_id, health)) in players {
        println!(&quot;Player {user_id} now has {health} health&quot;);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>In addition to specifying components in the query, you can also specify components that must be needed using <code>.requires</code> or components that must not be present using <code>.excludes</code>. These are useful for filtering out entities that should not be processed by the query.</p>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>Concepts are defined in the package manifest, and are used to define a collection of components that correspond to some concept in the game world. For example, a <code>Player</code> concept might be defined as a collection of components that describe the player’s health, inventory, and position.</p>
<p>Concepts have an ID (specified as the name of their TOML table), a name, a description, and required/optional components. Additionally, they can extend other concepts, which will cause them to inherit the components of the concepts they extend. Anything that is defined in the concept will override the definition in the concept it extends.</p>
<p>Required components must be present for an entity to satisfy a concept, while optional components are not required and can be used to provide additional information about the entity. As an example, a <code>CharacterAnimation</code> concept may require components to drive it, but can offer optional components as a way of configuring which animations should be used.</p>
<p>When specifying a concept’s components, the following optional parameters are available:</p>
<ul>
<li><code>suggested</code>: A suggested default for the value of the component. This is shown in documentation.</li>
<li><code>description</code>: A description of the component in the context of the concept, which may be different to the component’s description. This can be used to clarify how a component may be used within a concept. This is shown in documentation.</li>
</ul>
<p>These do not need to be specified, but are useful for providing additional information about the component.</p>
<p>For illustration, here are two concepts that are defined as part of Ambient’s default manifest:</p>
<pre><code class="language-toml">[concepts.Transformable]
name = &quot;Transformable&quot;
description = &quot;Can be translated, rotated and scaled.&quot;

[concepts.Transformable.components.required]
local_to_world = { suggested = &quot;Identity&quot; }

[concepts.Transformable.components.optional]
translation = { suggested = [0.0, 0.0, 0.0] }
rotation = { suggested = [0.0, 0.0, 0.0, 1.0] }
scale = { suggested = [1.0, 1.0, 1.0] }

[concepts.Camera]
name = &quot;Camera&quot;
description = &quot;Base components for a camera. You will need other components to make a fully-functioning camera.&quot;
extends = [&quot;transform::Transformable&quot;]

[concepts.Camera.components.required]
near = { suggested = 0.1 }
projection = { suggested = &quot;Identity&quot; }
projection_view = { suggested = &quot;Identity&quot; }
active_camera = { suggested = 0.0 }
&quot;transform::local_to_world&quot; = { suggested = &quot;Identity&quot; }
&quot;transform::inv_local_to_world&quot; = { suggested = &quot;Identity&quot; }
[concepts.Camera.components.optional]
&quot;app::main_scene&quot; = { description = &quot;Either the main or UI scene must be specified for this camera to be used.&quot; }
&quot;app::ui_scene&quot; = { description = &quot;Either the main or UI scene must be specified for this camera to be used.&quot; }
&quot;player::user_id&quot; = { description = &quot;If set, this camera will only be used for the specified user.&quot; }
</code></pre>
<p>In this example, the “Camera” concept contains all of the components from a transformable, as well as components of its own. This means that any entity that has the “camera” concept will also have the components from the “Transformable” concept.</p>
<p>In your Rust code, this will be represented as a struct that contains the components that are defined in the concept. This is generated as part of the same macro that enables other Ambient functionality within your Rust code.</p>
<p>For example, the <code>Camera</code> concept will generate a struct that looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
pub struct Camera {
    pub local_to_world: Mat4,
    pub near: f32,
    pub projection: Mat4,
    pub projection_view: Mat4,
    pub active_camera: f32,
    pub inv_local_to_world: Mat4,
    pub optional: CameraOptional,
}

#[derive(Clone, Debug, Default)]
pub struct CameraOptional {
    pub translation: Option&lt;Vec3&gt;,
    pub rotation: Option&lt;Quat&gt;,
    pub scale: Option&lt;Vec3&gt;,
    pub main_scene: Option&lt;()&gt;,
    pub ui_scene: Option&lt;()&gt;,
    pub user_id: Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Concept</code> struct implements the <code>Concept</code> trait, which offers several operations. Each of these fields represents a specific component from the concept.</p>
<p>This struct can be filled out with values and then converted to an <code>Entity</code> using the <code>Concept::make</code> method, or spawned using <code>Concept::spawn</code>.
Alternatively, it can be populated using the <code>Concept::get_{un}spawned</code> method, allowing for easy retrieval of all of the values of a concept from an entity or the ECS.</p>
<p>For more information, consult the API documentation on the <code>Concept</code> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>Ambient supports message passing between client and server, and from package to package. Message types are defined in the <code>ambient.toml</code> (see <a href="reference/./package.html#messages--messages">the reference</a>); these types can then be subscribed to and sent as needed.</p>
<h2 id="subscribing-to-messages"><a class="header" href="#subscribing-to-messages">Subscribing to messages</a></h2>
<p>Use the <code>MessageName::subscribe</code> method to subscribe to messages. This method is part of the <a href="https://docs.rs/ambient_api/latest/ambient_api/message/trait.ModuleMessage.html">ModuleMessage</a> and <a href="https://docs.rs/ambient_api/latest/ambient_api/message/trait.RuntimeMessage.html">RuntimeMessage</a> traits, and has a slightly different syntax depending on whether you are subscribing to a module or runtime message.</p>
<h2 id="dispatching-a-message"><a class="header" href="#dispatching-a-message">Dispatching a message</a></h2>
<p>Construct the message (a struct) and send it using one of the appropriate methods for your class of message. As an example, to send a package-defined <code>MyMessage</code> to all local packages (i.e. packages on “this side”):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MyMessage { some_field: 4. }.send_local_broadcast();
<span class="boring">}
</span></code></pre></pre>
<h2 id="defining-new-messages"><a class="header" href="#defining-new-messages">Defining new messages</a></h2>
<p>New messages can be defined in <code>ambient.toml</code>:</p>
<pre><code class="language-toml">[messages.MyMessage]
fields = { some_field = &quot;F32&quot; }
</code></pre>
<p>Read more in the <a href="reference/./package.html#messages--messages">package documentation</a>.</p>
<h2 id="using-messages-from-other-packages"><a class="header" href="#using-messages-from-other-packages">Using messages from other packages</a></h2>
<p>Add a <a href="reference/./package.html#dependencies--dependencies">dependency</a> to your package manifest,
pointing to the other package. It will then be available to your package to use underneath
the <code>packages</code> module; there is no difference in use between a message defined in your
package and one defined in another package.</p>
<p>Of note is that you can get the entity representing a package using the <code>entity</code> function
defined for all packages (i.e. <code>packages::my_dependency::entity()</code>); messages can then be
sent to that entity, ensuring that only it will handle the message.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models-1"><a class="header" href="#models-1">Models</a></h1>
<p>Models are 3D objects (characters, vehicles, buildings, etc) that can be rendered to the screen. They can be loaded from files, or procedurally generated.</p>
<h2 id="importing-a-model"><a class="header" href="#importing-a-model">Importing a model</a></h2>
<p>To use a model in Ambient, place it in the <code>assets</code> folder, and then create a <code>assets/pipeline.toml</code> file:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
</code></pre>
<p>See <a href="reference/./asset_pipeline.html">asset pipeline</a> for more details.</p>
<h2 id="spawning-a-model"><a class="header" href="#spawning-a-model">Spawning a model</a></h2>
<p>The model can then be spawned using <code>prefab_from_url</code>, assuming that <code>output_prefabs</code> is enabled in your <code>assets/pipeline.toml</code> file (it is enabled by default). Assuming your package is named <code>my_package</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(Transformable::suggested())
    .with(prefab_from_url(), packages::my_package::assets::url(&quot;MyModel.fbx&quot;))
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>The prefabs generated by the pipeline include the visual model and physics colliders.</p>
<p>If the code above lives in your <code>server.rs</code> file, it will create the physics colliders on the server.
The model, including any skeletons it may have, will always be loaded and spawned on the clientside, regardless of if the above code lives in <code>server.rs</code> or <code>client.rs</code>. It is not guaranteed that the model will be loaded on the server, so you should not rely on it being there.</p>
<p>You can also use <code>model_from_url</code> to load a model without the physics colliders.</p>
<h2 id="animating-a-model"><a class="header" href="#animating-a-model">Animating a model</a></h2>
<p>See <a href="reference/./animations.html">animations</a>.</p>
<h2 id="getting-models-for-your-project"><a class="header" href="#getting-models-for-your-project">Getting models for your project</a></h2>
<p>See <a href="reference/./getting_content.html">getting content</a> for a list of places where you can get models.</p>
<h2 id="manipulating-bones"><a class="header" href="#manipulating-bones">Manipulating bones</a></h2>
<p>You can get individual bones of a loaded model using the <code>animation::get_bone_by_bind_id</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit_id = Entity::new()
    .with_merge(Transformable::suggested())
    .with(prefab_from_url(), packages::my_package::assets::url(&quot;MyModel.fbx&quot;))
    .spawn();
let left_foot = animation::get_bone_by_bind_id(unit_id, &amp;BindId::LeftFoot).unwrap();
entity::set_component(left_foot, rotation(), Quat::from_rotation_x(0.3));
<span class="boring">}
</span></code></pre></pre>
<p>This will only work on the client at present, as the skeleton is not loaded on the server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchies-and-transforms"><a class="header" href="#hierarchies-and-transforms">Hierarchies and transforms</a></h1>
<p>Ambient supports hierarchies of entities using the <code>parent</code> and <code>children</code> components. The user only specifies the <code>parent</code> component; the <code>children</code> are automatically derived from the existing parents.
As an example, the following entities in the ECS</p>
<pre><code class="language-yml">entity a:
entity b:
  - parent: a
entity c:
  - parent: a
</code></pre>
<p>will produce the hierarchy:</p>
<pre><code>entity a
    entity b
    entity c
</code></pre>
<p>The <code>entity::add_child</code> and <code>entity::remove_child</code> functions can be used to add and remove children from a parent.</p>
<p>When using the <code>model_from_url</code> or <code>prefab_from_url</code> components, the entire model sub-tree will be spawned in, with the root of the sub-tree being added as a child to the entity with the component. Each entity in the sub-tree will be part of the hierarchy using their own <code>parent</code> and <code>children</code> components.</p>
<h2 id="transforms-in-hierarchies"><a class="header" href="#transforms-in-hierarchies">Transforms in hierarchies</a></h2>
<p>Hierarchies are commonly used for transforms where a root entity is moved around and all its children should move with it.
To apply transforms to a hierarchy, <code>local_to_parent</code> must be used:</p>
<pre><code class="language-yml">entity a:
  - local_to_world: Mat4(..)
entity b:
  - parent: a
  - local_to_parent: Mat4(..)
  - local_to_world: Mat4(..)
</code></pre>
<p>In this case, <code>b.local_to_world</code> will be calculated as <code>a.local_to_world * b.local_to_parent</code>.</p>
<p><code>local_to_world</code> and <code>local_to_parent</code> are the only matrices necessary here. However, it is often more convenient to work with <code>translation</code>, <code>rotation</code> and <code>scale</code> components:</p>
<pre><code class="language-yml">entity a:
  - local_to_world: Mat4(..)
  - translation: vec3(5., 2., 9.)
  - rotation: quat(..)
  - scale: vec3(0.5, 0.5, 1.)
entity b:
  - parent: a
  - local_to_parent: Mat4(..)
  - local_to_world: Mat4(..)
  - translation: vec3(-2., 0., 0.)
  - rotation: quat(..)
  - scale: vec3(1., 2., 1.)
</code></pre>
<p>In this case, the <code>local_to_world</code> and <code>local_to_parent</code> will automatically be recalculated from <code>translation</code>, <code>rotation</code> and <code>scale</code> whenever they change; the following computations will happen in this order:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a.local_to_world = mat4_from(a.scale, a.rotation, a.translation);
b.local_to_parent = mat4_from(b.scale, b.rotation, b.translation);
b.local_to_world = a.local_to_world * b.local_to_parent;
<span class="boring">}
</span></code></pre></pre>
<h3 id="mesh-transforms"><a class="header" href="#mesh-transforms">Mesh transforms</a></h3>
<p>The above will let you express any transform hierarchy, but to reduce the number of entities, you can also use
<code>mesh_to_local</code> and <code>mesh_to_world</code>. When <code>mesh_to_world</code> exists, it replaces <code>local_to_world</code> as the “final”
transform for the rendered mesh. It’s calculated as follows:</p>
<pre><code class="language-yml">entity a:
  - local_to_world: Mat4(..)
  - mesh_to_local: Mat4(..)
  - mesh_to_world: Mat4(..)
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mesh_to_world = local_to_world * mesh_to_local
<span class="boring">}
</span></code></pre></pre>
<p>This also means that you can attach a mesh in the middle of a hierarchy, with an offset. For instance, if you have
a bone hierarchy on a character, you can attach an mesh to the upper arm bone, but without <code>mesh_to_local/world</code> it
would be rendered at the center of the arm (inside the arm), so by using <code>mesh_to_local/world</code> you can offset it.</p>
<h2 id="opting-out-of-automatically-derived-children"><a class="header" href="#opting-out-of-automatically-derived-children">Opting out of automatically derived children</a></h2>
<p>If you wish to manage the <code>children</code> component yourself, you can attach an <code>unmanaged_children</code> component to your
entity. This stops <code>children</code> from being automatically populated, and it’s now up to you to populate the <code>children</code>
component to create a valid hierarchy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-pipeline"><a class="header" href="#asset-pipeline">Asset pipeline</a></h1>
<!-- markdownlint-disable-file MD024 -->
<p>Ambient features an automated asset pipeline that is capable of loading and processing a number of assets and formats.</p>
<p>Within the <code>assets</code> folder, or any subdirectory of it, create a file with a name ending in <code>pipeline.toml</code>; examples include <code>pipeline.toml</code> and <code>hello_pipeline.toml</code>. The prefix can be used to disambiguate between different pipelines.</p>
<p>This pipelines will look at, but not necessarily process, all of the files adjacent to it in the folder.</p>
<h2 id="models-2"><a class="header" href="#models-2">Models</a></h2>
<p>The <code>Models</code> pipeline can be used to compile a model, or models, to meshes that can be used by Ambient. Additionally, by
default, prefabs are created for each mesh. These prefabs can have components automatically added to them through the
<code>prefab_components</code> field of the pipeline.</p>
<h3 id="supported-formats"><a class="header" href="#supported-formats">Supported formats</a></h3>
<ul>
<li>FBX: Native support</li>
<li>glTF: Native support</li>
<li>Unity models: Native support</li>
<li>Quixel models: Native support</li>
<li>~30 other formats: This support is provided through the <a href="https://github.com/assimp/assimp">assimp</a> library. It is not
guaranteed to be fully integrated. By default, Ambient is not built with <code>assimp</code> support due to issues with cross-platform builds.</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="basic-models"><a class="header" href="#basic-models">Basic models</a></h4>
<p>The following will load <code>.glb</code> and <code>.fbx</code> files in the folder or any of the sub-folders.</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
</code></pre>
<h4 id="different-pipelines-for-different-files"><a class="header" href="#different-pipelines-for-different-files">Different pipelines for different files</a></h4>
<p>You can use the <code>sources</code> attribute to restrict different configurations to different files:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
sources = [ &quot;physical/*.glb&quot; ]

[pipelines.collider]
type = &quot;FromModel&quot;

[[pipelines]]
type = &quot;Models&quot;
sources = [ &quot;ghosts/*.glb&quot; ]
</code></pre>
<p><code>sources</code> accepts a list of glob patterns, so you can target a single file or a pattern to select all files in a
directory (<code>*.glb</code>) or sub-tree (<code>**/test.glb</code>).</p>
<h4 id="combining-a-model-with-textures"><a class="header" href="#combining-a-model-with-textures">Combining a model with textures</a></h4>
<p>The following example is the asset pipeline for the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/assets/material_overriding"><code>material_overriding</code> example</a>. It applies a custom material to
the imported mesh.</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
sources = [&quot;*.glb&quot;]
prefab_components = &quot;{ \&quot;ib2djsnjew5tb2k5igq6le7rzjdwlvhq::is_the_best\&quot;: false }&quot;

[[pipelines.material_overrides]]

[pipelines.material_overrides.filter]
type = &quot;All&quot;

[pipelines.material_overrides.material]
name = &quot;Planks&quot;
base_color = &quot;./Planks037B_1K-PNG/Planks037B_1K_Color.png&quot;
normalmap = &quot;./Planks037B_1K-PNG/Planks037B_1K_NormalGL.png&quot;
roughness_factor = 1.0
metallic_factor = 0.0
</code></pre>
<h4 id="generating-a-pipeline-in-code"><a class="header" href="#generating-a-pipeline-in-code">Generating a pipeline in code</a></h4>
<p>By using a build script, you can also generate a <code>pipeline.toml</code> using Rust code. For instance with a <code>build.rs</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">use ambient_pipeline_types::{
    models::{ModelTextureSize, ModelTransform},
    ModelImporter, ModelsPipeline, Pipeline, PipelineProcessor, PipelinesFile,
};

fn main() {
    PipelinesFile {
        pipelines: vec![Pipeline {
            processor: PipelineProcessor::Models(ModelsPipeline {
                importer: ModelImporter::Regular,
                cap_texture_sizes: Some(ModelTextureSize::Custom(2)),
                transforms: vec![ModelTransform::RotateZ { deg: 90. }],
                ..Default::default()
            }),
            sources: vec![&quot;*&quot;.to_string()],
            tags: vec![],
            categories: vec![],
        }],
    }
    .save_to_file(&quot;assets/pipeline.toml&quot;)
    .unwrap();
}
</code></pre></pre>
<p>Which will generate the following toml:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
output_prefabs = false
output_animations = false
sources = [&quot;*&quot;]

[pipelines.cap_texture_sizes]
Custom = 2

[[pipelines.transforms]]
type = &quot;RotateZ&quot;
deg = 90.0
</code></pre>
<p>See the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/assets/generate_pipeline">generate pipeline example</a> for a full example.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>If you are using components in your prefab and are hot-reloading it, the incoming prefab will overwrite any
corresponding components on the current state of the entity. These components should only be used for static data - that
is, <code>max_hitpoints</code> but not <code>current_hitpoints</code>.</li>
</ul>
<h2 id="models-3"><a class="header" href="#models-3">Models</a></h2>
<h3 id="regular"><a class="header" href="#regular">Regular</a></h3>
<p>Consumes model file formats into a hierarchy of entities, materials, and meshes.</p>
<h4 id="supported-formats-1"><a class="header" href="#supported-formats-1">Supported formats:</a></h4>
<ul>
<li><code>glb</code></li>
<li><code>gltf</code></li>
<li><code>fbx</code></li>
<li><code>obj</code></li>
</ul>
<h3 id="unity"><a class="header" href="#unity">Unity</a></h3>
<p>Consumes Unity packages processing all meshes, textures and materials, and LoD levels into a normalized form to consume in Ambient.
Usage of a processed model during runtime is identical to <code>Regular</code>.</p>
<h3 id="quixel"><a class="header" href="#quixel">Quixel</a></h3>
<p>Imports Quixel packages.</p>
<p>Supports collections, LoD levels, etc.</p>
<h2 id="materials"><a class="header" href="#materials">Materials</a></h2>
<p>Import materials from a variety of formats. Overrides can be specified in the pipeline.</p>
<p>Detailed documentation is pending, but please consult the <a href="reference/asset_pipeline.html#reference">Reference</a>.</p>
<h3 id="supported-formats-2"><a class="header" href="#supported-formats-2">Supported formats</a></h3>
<ul>
<li><code>jpg</code></li>
<li><code>png</code></li>
<li><code>gif</code></li>
<li><code>webp</code></li>
<li>as well as other common image formats</li>
</ul>
<h2 id="audio-1"><a class="header" href="#audio-1">Audio</a></h2>
<p>Detailed documentation is pending, but please consult the <a href="reference/asset_pipeline.html#reference">Reference</a>.</p>
<h3 id="supported-formats-3"><a class="header" href="#supported-formats-3">Supported formats</a></h3>
<ul>
<li><code>ogg</code></li>
<li><code>wav</code></li>
<li><code>mp3</code></li>
</ul>
<h2 id="reference-1"><a class="header" href="#reference-1">Reference</a></h2>
<p>See <code>rustdoc</code> for a complete reference of supported pipelines, model importers, material configurations,
and the like.</p>
<pre><code class="language-sh">cargo doc --open -p ambient_pipeline_types
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-1"><a class="header" href="#networking-1">Networking</a></h1>
<p>Networking is a critical component of Ambient, as it enables communication between the client and the server. This document explains some of the specifics behind the current protocol.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>Currently, the Ambient runtime supports both desktop and web clients, using QUIC through the <code>quinn</code> library/WebTransport through <code>h3-webtransport</code> respectively as its communication protocol.</p>
<p>The HTTP (TCP) port is <code>8999</code>, and the QUIC (UDP) port is <code>9000</code>.</p>
<h2 id="entities-1"><a class="header" href="#entities-1">Entities</a></h2>
<p>The Ambient runtime synchronizes all entities by default. Only components marked as <code>Networked</code> will be sent to the client. Most core components are <code>Networked</code>, but custom components are not by default; this is something developers have to opt into. It is important to note that this may have unintended ramifications in terms of cheating, especially for hostile clients.</p>
<p>To disable syncing an entity to the client, attach the <code>no_sync</code> component to it. This will prevent the entity from being sent to the client.</p>
<p>The client is fundamentally designed around runtime flexibility of logic, which is non-ideal for avoiding cheaters. Further research and development are required, but it is likely that there is no silver bullet, and the solution will be game-dependent.</p>
<h3 id="entity-synchronization"><a class="header" href="#entity-synchronization">Entity synchronization</a></h3>
<p>The Ambient runtime synchronizes entities using a diff-based approach. The server sends a <code>WorldDiff</code> to the client, which contains a list of entities to spawn and despawn, and components to add, update, and remove.</p>
<p>Note that some operations might be batched for performance or not included in the update sent to the clients if there is no effective change in value. For example, adding 0 to a number or changing a boolean to <code>false</code> and back to <code>true</code> within the same frame might not emit an update and might not trigger a <code>change_query</code>. We recommend using messaging if such events are important to your game.</p>
<p>Currently, the client applies the changes to its local world as soon as they are received.</p>
<h2 id="logic-and-prediction"><a class="header" href="#logic-and-prediction">Logic and Prediction</a></h2>
<p>All gameplay logic is currently server-authoritative. We currently do not have any form of latency-hiding, including prediction, rollback, or clientside logic. We have previously experimented with rollback, but it was removed due to difficulties in genericising its implementation, as the solution would have to be different for each class of game.</p>
<p>Our plan is to continue improving our data model to enable user-defined prediction, provided as an Ambient package, but this work is ongoing. In the meantime, prediction can be done manually by sharing code with some caveats (i.e. physics does not run on the client).</p>
<h2 id="messaging"><a class="header" href="#messaging">Messaging</a></h2>
<p>The Ambient runtime supports messaging from the client to the server and vice versa through structured messages. These messages are defined ahead of time in <code>ambient.toml</code> and made accessible to code that consumes that <code>ambient.toml</code>.</p>
<p>This messaging can be reliable (QUIC unistream) or unreliable (QUIC datagram). Developers can use this to define their networked behavior, including customized prediction.</p>
<p>See <a href="reference/./messages.html">the messages reference</a> for more details.</p>
<h2 id="proxy"><a class="header" href="#proxy">Proxy</a></h2>
<p>From 0.2 onwards, Ambient will establish a connection to a NAT traversal proxy by default (this can be turned off with <code>--no-proxy</code>). This proxy allows users to connect to an Ambient server, even when the server is behind NAT or similar. Check the <a href="https://github.com/AmbientRun/AmbientProxy">AmbientProxy repository</a> for more details about the proxy itself.</p>
<p>The Ambient server (i.e. Ambient when started with <code>run</code> or <code>serve</code>) connects to the proxy using QUIC (using the <code>quinn</code> library) and allocates a proxy endpoint. In response, the proxy provides the endpoint’s details as well as an URL for asset downloading. The allocated proxy endpoint can be used by players to connect (<code>ambient join ...</code>) to the game server, even if it is running behind a NAT.</p>
<p>Communication between the proxy and players uses the same protocol as with a direct connection to the Ambient server; the only difference is the proxy acting as an intermediary.</p>
<h2 id="certificates"><a class="header" href="#certificates">Certificates</a></h2>
<p>By default, Ambient bundles a self-signed certificate that is used by the server and trusted by the client. This enables connecting to the server without any additional configuration, but may limit direct connections from other clients.</p>
<p>We recommend use of the proxy, or using your own certificate. In future, we may offer an option to relax certificate verification for native servers and clients.</p>
<p>To use your own certificate:</p>
<ul>
<li>specify <code>--cert</code> and <code>--key</code> for the server:
<pre><code class="language-sh">ambient serve --cert ./localhost.crt --key ./localhost.key
</code></pre>
</li>
<li>specify <code>--ca</code> for the client if the certificate authority that signed the certificate is not present within the client’s system roots
<pre><code class="language-sh">ambient join 127.0.0.1:9000
</code></pre>
</li>
</ul>
<p>If a custom certificate is specified, the bundled certificates will <em>not</em> be used as a fallback.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<p>See the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/skinmesh">skinmesh example</a> for a complete example.</p>
<h2 id="animation-assets"><a class="header" href="#animation-assets">Animation assets</a></h2>
<p>To work with animations, you will need some animation clips. A good way to get started is
by going to <a href="https://www.mixamo.com/#/">Mixamo</a> and downloading some characters and animations.</p>
<p>In the <code>assets</code> folder of your package, place your models and animations. Additionally, in the same folder,
make sure you have a <code>pipeline.toml</code> which can process models and animations:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
</code></pre>
<h3 id="finding-the-clip-urls"><a class="header" href="#finding-the-clip-urls">Finding the clip URLs</a></h3>
<p>The <code>ambient build</code> command will build the assets. You can browse the <code>build/assets</code> folder to see what
was produced by the command.</p>
<p>As an example:</p>
<ul>
<li>The <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/skinmesh">skinmesh example</a>
has an animation called <code>assets/Capoeira.fbx</code>.</li>
<li>The build process will produce <code>build/ambient_example_skinmesh/assets/Capoeira.fbx/animations/mixamo.com.anim</code>.</li>
<li>The animation clip URL is this path after <code>assets/</code>: <code>Capoeira.fbx/animations/mixamo.com.anim</code>.</li>
</ul>
<p>In the following examples, it is assumed that you have imported <code>assets</code> from a package, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use packages::ambient_example_skinmesh::assets;
<span class="boring">}
</span></code></pre></pre>
<h2 id="animation-player"><a class="header" href="#animation-player">Animation player</a></h2>
<p>An <code>AnimationPlayerRef</code> is used to play animations. The player executes a graph of animation nodes; at present,
the two nodes that exist are <code>PlayClipFromUrlNodeRef</code> and <code>BlendNodeRef</code>.</p>
<p>Here’s an example of how to set up a graph and play it for a single animation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clip = PlayClipFromUrlNodeRef::new(
    assets::url(&quot;Capoeira.fbx/animations/mixamo.com.anim&quot;)
);
let player = AnimationPlayerRef::new(&amp;clip);

// Let's load a character model to apply the animation to.
Entity::new()
    .with_merge(Transformable::suggested())
    .with(prefab_from_url(), assets::url(&quot;Peasant Man.fbx&quot;))
    .with(apply_animation_player(), player.0)
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>The same animation player can be attached to multiple models.</p>
<h3 id="blending-animations-together"><a class="header" href="#blending-animations-together">Blending animations together</a></h3>
<p>A <code>BlendNodeRef</code> can be used to blend two animations together:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capoeira = PlayClipFromUrlNodeRef::new(
    assets::url(&quot;Capoeira.fbx/animations/mixamo.com.anim&quot;)
);
let robot = PlayClipFromUrlNodeRef::new(
    assets::url(&quot;Robot Hip Hop Dance.fbx/animations/mixamo.com.anim&quot;)
);
let blend = BlendNodeRef::new(&amp;capoeira, &amp;robot, 0.3);
let anim_player = AnimationPlayerRef::new(&amp;blend);
<span class="boring">}
</span></code></pre></pre>
<p>This will blend <code>capoeira</code> (30%) and <code>robot</code> (70%) together to form one output animation.</p>
<h3 id="masked-blending"><a class="header" href="#masked-blending">Masked blending</a></h3>
<p>A common use case for blending is to blend two animations together for different parts of the body;
this is achieved using masking. Here’s an example of how to blend two animations together for the upper and lower
body:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capoeira = PlayClipFromUrlNodeRef::new(
    assets::url(&quot;Capoeira.fbx/animations/mixamo.com.anim&quot;)
);
let robot = PlayClipFromUrlNodeRef::new(
    assets::url(&quot;Robot Hip Hop Dance.fbx/animations/mixamo.com.anim&quot;)
);

let blend = BlendNodeRef::new(&amp;capoeira, &amp;robot, 0.0);
blend.set_mask_humanoid_lower_body(1.0);

let anim_player = AnimationPlayerRef::new(&amp;blend);
<span class="boring">}
</span></code></pre></pre>
<p>This will play the <code>capoeira</code> at the upper body, and the <code>robot</code> dance for the lower body.
The <code>set_mask_humanoid_lower_body</code> and <code>set_mask_humanoid_upper_body</code> functions are convenience
functions for setting the mask for the upper and lower body.</p>
<p>The blend node’s weight is still relevant when used with masking, but can also be set per-bone using the mask.
Setting <code>BlendNodeRef::new(&amp;capoeira, &amp;robot, 0.3)</code> and then <code>blend.set_mask_humanoid_lower_body(0.9)</code> will play all
nodes in the <code>capoeira</code> animation at 30%, except for the lower body, which will play it at 90%. If no mask is set,
the weight is used for all bones.</p>
<h3 id="attaching-entities-to-a-skeleton"><a class="header" href="#attaching-entities-to-a-skeleton">Attaching entities to a skeleton</a></h3>
<p>Entities can be attached to bones on a skeleton. This is done by adding a <code>parent</code> component to the entity that
points to the bone to be attached to. The entity should also have a <code>local_to_parent</code> component, which will be
the transformation of the entity relative to the bone. For more information, see the documentation on <a href="reference/hierarchies.html">hierarchies</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let left_foot = animation::get_bone_by_bind_id(unit_id, &amp;BindId::LeftFoot).unwrap();
let ball = Entity::new()
    .with_merge(Transformable::suggested())
    .with_merge(Sphere::suggested())
    .with(parent(), left_foot)
    .with(local_to_parent(), Default::default())
    // Without reset_scale, the ball would take the scale of the
    // bone we're attaching it to
    .with(reset_scale(), ())
    .spawn();
entity::add_child(left_foot, ball);
<span class="boring">}
</span></code></pre></pre>
<p>This will spawn a ball and attach it to the left foot of the character.</p>
<h3 id="pre-loading-animations"><a class="header" href="#pre-loading-animations">Pre-loading animations</a></h3>
<p>Animations can be pre-loaded by creating a <code>PlayClipFromUrlNodeRef</code> node and waiting for it to load:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capoeira = PlayClipFromUrlNodeRef::new(
    assets::url(&quot;Capoeira.fbx/animations/mixamo.com.anim&quot;)
);
capoeira.wait_for_load().await;
<span class="boring">}
</span></code></pre></pre>
<p>The clip will remain loaded as long as the object survives.</p>
<h3 id="retargeting"><a class="header" href="#retargeting">Retargeting</a></h3>
<p>It is possible to play an animation that was made for one character on another character.
Retargeting may be necessary to remap the animation from the original character’s skeleton to your target
character’s skeleton.</p>
<p>To do this, <code>PlayClipFromUrlNodeRef::set_retargeting</code> can be used to configure the retargeting for a given clip.
Additionally, <code>PlayClipFromUrlNodeRef::apply_base_pose</code> may be necessary to change the origin of the animation
for correctness.</p>
<p>If you’re using Mixamo for animations, you can do retargeting through Mixamo itself to get the best results.</p>
<h3 id="animation-nodes-lifetimes-and-ownership"><a class="header" href="#animation-nodes-lifetimes-and-ownership">Animation nodes lifetimes and ownership</a></h3>
<p>The animation player and nodes all live in the ECS. The <code>AnimationPlayerRef</code>, <code>PlayClipFromUrlNodeRef</code> and other nodes
are wrappers around an <code>EntityId</code>. You are responsible for despawning them when you’re done with them, by calling
<code>.despawn()</code>, which will remove the node and all the children.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-1"><a class="header" href="#physics-1">Physics</a></h1>
<p>Physics in Ambient is powered by Nvidia’s PhysX (<a href="https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Index.html">user guide</a>, <a href="https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxapi/files/index.html">PhysX API documentation</a>).</p>
<h2 id="colliders"><a class="header" href="#colliders">Colliders</a></h2>
<p>To get started with physics, you’ll need <em>colliders</em> - 3D shapes that represent objects, often with simplified geometry. Ambient provides a number of primitive colliders to assist with basic shapes; as an example, here is how you would create a cube collider:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(Transformable::suggested())
    .with(cube_collider(), Vec3::ONE)
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>See the <a href="https://docs.rs/ambient_api/latest/ambient_api/physics/index.html">API docmentation</a> for other colliders. Most commonly, you, or the prefab generated by the <a href="reference/./asset_pipeline.html">asset pipeline</a>, will <a href="reference/./physics.html#colliders-from-models">use <code>collider_from_url</code></a> to load a collider from a file.</p>
<p>The code above will create a physics collider, but this collider will not be visible without a
visual representation. The <code>cube</code> component can be used to attach a cube model to the entity:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(Transformable::suggested())
    .with(cube_collider(), Vec3::ONE)
    .with(cube(), ())
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<h2 id="dynamic-objects"><a class="header" href="#dynamic-objects">Dynamic objects</a></h2>
<p>The above code will create <em>static</em> colliders; these can be collided with, but do not move.
This is ideal for level geometry, but not for moving objects. To create a dynamic object,
you’ll need a collider and the <code>physics_controlled</code> and <code>dynamic</code> components:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(Transformable::suggested())
    .with(cube_collider(), Vec3::ONE)
    .with(cube(), ())
    .with(physics_controlled(), ())
    .with(dynamic(), true)
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>physics_controlled</code> is used to indicate that any changes to the physics representation of the object should be copied back to the ECS (including translation and rotation).</li>
<li><code>dynamic</code> indicates it’s an object that can move.</li>
</ul>
<h2 id="collision-message"><a class="header" href="#collision-message">Collision message</a></h2>
<p>The <code>Collision</code> message is sent when two or more objects collide with each other. It contains a list of the colliding entities:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Collision::subscribe(move |msg| {
    println!(&quot;Bonk! {:?} collided&quot;, msg.ids);
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="colliders-from-models"><a class="header" href="#colliders-from-models">Colliders from models</a></h2>
<p>Model files can also be used as colliders (i.e. <code>.gltf</code> and <code>.fbx</code> files). Add this to your <code>pipeline.toml</code>:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;

[pipelines.collider]
type = &quot;FromModel&quot;
</code></pre>
<p>Colliders will be made for the models, and then included as part of the associated prefab for
the model. You can then use the prefab to create entities with colliders:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(Transformable::suggested())
    .with(prefab_from_url(), assets::url(&quot;shape.glb&quot;))
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>See <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/physics/basics">the physics example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-2"><a class="header" href="#audio-2">Audio</a></h1>
<p>Ambient has basic audio functionality on native including sound playback, panning and volume control.
Audio is not yet supported on the web, but will be implemented in the near-future.</p>
<p>3D audio with HRTF is also included but is considered highly experimental.</p>
<p>The API described here is <em>highly</em> subject to change, and will likely be completely redesigned in the future.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To use audio, you need to put the audio files into the <code>assets</code> folder, and then edit the <code>pipeline.toml</code>.</p>
<p>Check the <code>assets</code> folder in the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/physics/basics">physics example</a> to see how this is done.</p>
<p>Audio should be loaded and played in clientside WASM/<code>client.rs</code> (the API is not supported on the server). <a href="reference/./package.html#messages--messages">Messages</a> can be used by the server to tell the client to play a sound effect.</p>
<h1 id="examples-with-audio"><a class="header" href="#examples-with-audio">Examples with audio</a></h1>
<ul>
<li><code>./guest/rust/examples/basics/physics</code> (spatial audio)</li>
<li><code>./guest/rust/examples/ui/audio_ctrl</code></li>
<li><code>./guest/rust/packages/games/music_sequencer</code></li>
</ul>
<p>The general idea is that in the ECS system, you can create an <code>audio::AudioPlayer</code> or <code>audio::SpatialAudioPlayer</code>. You can set the property of these players with methods such as <code>set_amplitude</code>. Then you can use the <code>player</code> to play a sound assets. This will actually return an <code>EntityId</code>.</p>
<p>By <code>add_component</code> to the entity, you can control the playing sound as well. The <code>audio_ctrl</code> example shows the details. When the sound playing finishes, the entity will automatically despawn. To stop a playing sound in advance, see the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui/audio_ctrl">audio_ctrl example</a>.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    let player = audio::AudioPlayer::new();
    player.set_amplitude();
    let playing_sound = player.play(assets::url(&quot;sound.ogg&quot;));
    entity::add_component(playing_sound, amplitude(), 0.1);
}
</code></pre></pre>
<h2 id="deciding-whether-to-convert-audio-formats"><a class="header" href="#deciding-whether-to-convert-audio-formats">Deciding whether to convert audio formats</a></h2>
<p>Currently, we support <code>wav</code>, <code>mp3</code>, and <code>ogg</code> audio file formats. If you use an <code>mp3</code> format, it will be converted to <code>ogg</code> during the build process. However, you can use either “.mp3” or “.ogg” in the <code>assets::url</code> function.</p>
<p>In some cases, you may want to explicitly control whether the audio is converted in order to save space or maintain the best audio quality. This is particularly relevant for <code>wav</code> files, which are large when unconverted but offer lossless playback. You can manage this setting in the <code>pipeline.toml</code> file.</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Audio&quot;
convert = true
</code></pre>
<p>If you convert a <code>wav</code> file, then you need to use <code>.ogg</code> in <code>assets::url</code>.
If the <code>convert</code> entry is missing, the default behaviour is no conversion.</p>
<h2 id="debug-spatial-audio"><a class="header" href="#debug-spatial-audio">Debug (spatial) audio</a></h2>
<p>In some cases, e.g. an FPS game, you want to test how one client’s movement sounds to the other client. Then use <code>--mute-audio</code> flag with <code>ambient</code> cli. For example:</p>
<pre><code>ambient run --mute-audio
</code></pre>
<p>This will mute the client opened with this command while the rest clients won’t be influenced.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<p>Ambient’s UI system is heavily inspired by React (with hooks), and follows many of the same patterns.
Take a look at the <a href="https://react.dev/reference/react">React documentation</a> to learn how hooks work in general.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>Here’s a complete example of a minimal counter app:</p>
<pre><pre class="playground"><code class="language-rust">use ambient_api::prelude::*;
use ambient_ui::prelude::*;

#[element_component]
fn App(hooks: &amp;mut Hooks) -&gt; Element {
    let (count, set_count) = use_state(hooks,0);
    FlowColumn::el([
        Text::el(format!(&quot;We've counted to {count} now&quot;)),
        Button::new(&quot;Increase&quot;, move |_| set_count(count + 1)).el(),
    ])
}

#[main]
pub fn main() {
    App.el().spawn_interactive();
}
</code></pre></pre>
<p><a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui">See all UI examples here</a>.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The layout is roughly based on <a href="https://docs.microsoft.com/en-us/dotnet/desktop/winforms/controls/layout?view=netdesktop-6.0#container-flow-layout">Windows Forms</a>.</p>
<p>There are two major layout components, <code>Dock</code> and <code>Flow</code> (which includes <code>FlowColumn</code> and <code>FlowRow</code>).</p>
<p><code>Dock</code> is top-down: it starts with a given area (say the screen) and then divides it into smaller pieces with each new element added to it.</p>
<p><code>Flow</code> is bottom-up: it auto-resizes itself to fit its constituent components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributing"><a class="header" href="#distributing">Distributing</a></h1>
<p>This covers how to package and distribute games and assets.</p>
<h2 id="deploying-to-the-ambient-platform"><a class="header" href="#deploying-to-the-ambient-platform">Deploying to the Ambient platform</a></h2>
<p>Deploying to the <a href="https://ambient.run">Ambient platform</a> is the easiest way to share
your content with the world. Any <a href="reference/./package.html">package</a> can be deployed with:</p>
<pre><code class="language-sh">$ ambient deploy
Package &quot;my-project&quot; deployed successfully!
  Deployment ID: deployment_id
  Web URL: 'https://ambient.run/packages/package_id/deployment/deployment_id'
</code></pre>
<p>This will package and upload your creation to the platform. The web URL in the output can be used to browse your game or asset. If you’re on a WebGPU enabled browser, the game can be played directly on the website. Any content upload to the Ambient platform is subject to our <a href="https://www.ambient.run/terms-of-service">terms of services</a>.</p>
<p>If a <code>screenshot.png</code> is present in the package’s directory, it will be used as the game’s thumbnail on the Ambient website. We recommend you include one.</p>
<p>In the case your package is a game, it can be played directly on the website (if you’re on a WebGPU enabled browser). Additionally, game servers will automatically be spun up when someone wants to play your game.</p>
<h2 id="putting-your-game-on-itchio"><a class="header" href="#putting-your-game-on-itchio">Putting your game on itch.io</a></h2>
<p>To put your game on itch.io, you just need to deploy it to ambient.run first, and then upload the html app for your game which you can download from your games page on ambient.run. Here are the detailed steps:</p>
<ol>
<li>Run <code>ambient deploy</code> to deploy your game to ambient.run (see above for details)</li>
<li>Go to your game page on https://ambient.run, i.e. something like https://ambient.run/packages/uigiqyr7qugdncpzkyzinvwxh26daahx</li>
<li>Download the itch html app (in the sidebar to the left)</li>
<li>Go to http://itch.io and create a new project (arrow next to your profile -&gt; upload new project)</li>
<li>Change the “Kind of project” to “HTML”</li>
<li>Click “Upload files” and pick the <code>.html</code> file you just downloaded from ambient.run</li>
<li>Click “This file will be played in the browser”</li>
<li>Fille out any other information you’d like, then hit “Save”</li>
<li>Done! Your game should now be playable from itch.io</li>
</ol>
<h2 id="self-hosted"><a class="header" href="#self-hosted">Self-hosted</a></h2>
<p>An important principle for us is “freedom of movement”: if you don’t want to use the Ambient platform for
your work, you don’t have to. Packages can be deployed to your own filehost, and game servers can run
on your own platform.</p>
<p>As this path is less well-trodden, we’re still working on making this as easy as possible. If you encounter any issues, please reach out to us on <a href="https://discord.gg/ambient">Discord</a> or <a href="https://github.com/AmbientRun/Ambient/issues">GitHub</a>.</p>
<h3 id="packages-1"><a class="header" href="#packages-1">Packages</a></h3>
<p>To distribute your packages (games and assets) using your own servers, use <code>ambient build</code>, take the
resulting <code>build</code> folder and put it on any file server (e.g. a S3 bucket).</p>
<p>You can then use <code>ambient run https://address.to/your/content</code> to run that content.</p>
<h3 id="game-servers"><a class="header" href="#game-servers">Game servers</a></h3>
<p>We provide a <a href="https://github.com/AmbientRun/Ambient/pkgs/container/ambient">Docker image</a> that can be used
to deploy your game servers.</p>
<h2 id="distributing-a-desktop-version-of-your-game"><a class="header" href="#distributing-a-desktop-version-of-your-game">Distributing a desktop version of your game</a></h2>
<p>It is possible to distribute a native desktop version of your game, but support for this is still experimental and subject to change. The assets will still be served from the Ambient platform/the URL you specify, but the game will run natively on the user’s machine.</p>
<p>Create a <code>launch.json</code> that looks like this:</p>
<pre><code class="language-json">{
  &quot;args&quot;: [&quot;run&quot;, &quot;https://assets.ambient.run/1QI2Kc6xKnzantTL0bjiOQ&quot;]
}
</code></pre>
<p>The address should point to a deployment of your game. <code>ambient deploy</code> can be used to deploy your game, and will give you an address back.</p>
<p>Package the <code>launch.json</code> together with the <code>ambient.exe</code> binary. The <code>ambient.exe</code> can be renamed to your liking (i.e. <code>my_game.exe</code>).</p>
<p>This can then be deployed to any platform that expects native desktop apps, including Steam and Epic Games.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-ci"><a class="header" href="#setting-up-ci">Setting up CI</a></h1>
<h2 id="github"><a class="header" href="#github">Github</a></h2>
<p>Create a file called <code>.github/workflows/deploy.yaml</code> in your project, and with the following content:</p>
<pre><code class="language-yaml">name: Deploy to Ambient
&quot;on&quot;:
  push:
    branches:
      - main
jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          target: wasm32-unknown-unknown
      - uses: Swatinem/rust-cache@v2
      - uses: actions-rs/install@v0.1
        with:
          crate: ambient
          version: latest
          use-tool-cache: true
      - run: ambient deploy --token ${{ secrets.AMBIENT_TOKEN }}
</code></pre>
<p>You will also need to set up the AMBIENT_TOKEN secret in your github project. You can get your token from your user project on http://ambient.run</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>A brief list of terms used by Ambient and their definitions. This is incomplete - let us know if there’s anything you need clarified!</p>
<ul>
<li><strong>Concept</strong>: A collection of components defined in an <code>ambient.toml</code> that, when present together, imply something about the entity they’re attached to. Similar to Go’s interfaces.</li>
<li><strong>ECS</strong>: <a href="https://en.wikipedia.org/wiki/Entity_component_system">https://en.wikipedia.org/wiki/Entity_component_system</a></li>
<li><strong><code>ElementComponent</code></strong>: A piece of UI that can be rendered. Similar to React’s Components.</li>
<li><strong>Prefab</strong>: A entity or group of entities. Often an entity with a model and a collider attached to it.</li>
<li><strong>PVD</strong>: <a href="https://developer.nvidia.com/physx-visual-debugger">PhysX Visual Debugger</a>.</li>
<li><strong>WASM/WebAssembly</strong>: <a href="https://webassembly.org/">https://webassembly.org/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common pitfalls</a></h1>
<p>Be aware that a lot of problems are caused by mismatching versions of Ambient. To check your version, run <code>ambient --version</code> and make sure it matches the version in your <code>Cargo.toml</code> file.</p>
<h2 id="the-examples-dont-work"><a class="header" href="#the-examples-dont-work">The examples don’t work</a></h2>
<p>This is most often because of mismatching the ambient version with the
examples version. See <a href="reference/../user/running_examples.html">running examples</a>.</p>
<h2 id="my-clientside-wasm-module-crashes-when-accessing-a-component-from-the-server-and-unwrapping-it"><a class="header" href="#my-clientside-wasm-module-crashes-when-accessing-a-component-from-the-server-and-unwrapping-it">My clientside WASM module crashes when accessing a component from the server and unwrapping it</a></h2>
<p>Your clientside WASM can run before the server has finished running its WASM, so the component you’re trying to access may not have been created yet.</p>
<p>To fix this, consider using <code>entity::wait_for_component</code>, which is an async helper that will stall execution until the component is available.</p>
<h2 id="my-object-with-a-random-color-is-black-sometimes"><a class="header" href="#my-object-with-a-random-color-is-black-sometimes">My object with a random color is black sometimes</a></h2>
<p>The <code>color</code> component is a <code>Vec4</code>. Using <code>rand::random</code> to populate it will
result in the <code>w</code>/alpha channel also being between 0 and 1, which means your
object may be black and/or disappear if the alpha is below the default alpha
cut-off.</p>
<p>To fix this, use a random <code>Vec3</code> for your color and then extend it to a <code>Vec4</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let color = rand::random::&lt;Vec3&gt;().extend(1.0);
<span class="boring">}
</span></code></pre></pre>
<h2 id="my-character-controller-is-unaffected-by-gravity"><a class="header" href="#my-character-controller-is-unaffected-by-gravity">My character controller is unaffected by gravity</a></h2>
<p>PhysX, which we use for physics, does not apply gravity to character controllers.</p>
<p>You can account for this by applying gravity to the character controller yourself;
an example of this can be found in <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/packages/std/character_movement/src/server.rs">the <code>character_movement</code> standard package</a>
which maintains a <code>vertical_velocity</code> component and uses it to simulate gravity.</p>
<h2 id="my-cameras-view-matrix-is-all-nans"><a class="header" href="#my-cameras-view-matrix-is-all-nans">My camera’s view matrix is all NaNs</a></h2>
<p>This can happen when the transformation used to position the camera in the world is invalid.</p>
<p>There are several potential causes, including:</p>
<ul>
<li>The camera is positioned at the origin, and is looking at the origin.</li>
<li>The camera’s <code>lookat_up</code> vector is parallel to the <code>lookat_target</code> vector. This can happen by default if your <code>lookat_target</code> is above or below the camera as <code>lookat_up</code> defaults to +Z.</li>
<li>There is a division by zero somewhere in the camera’s transformation. This could happen if your gameplay code for controlling the camera does not account for the possibility of a zero denominator (i.e. no time passing, or no distance travelled).</li>
</ul>
<h2 id="fails-to-start-on-linux-error-in-surfaceconfigure-parent-device-is-lost"><a class="header" href="#fails-to-start-on-linux-error-in-surfaceconfigure-parent-device-is-lost">Fails to start on Linux (Error in <code>Surface::configure: parent device is lost</code>)</a></h2>
<p>If you’re running Wayland, you may have to start Ambient with <code>WAYLAND_DISPLAY=wayland-1 ambient run</code>.
See <a href="https://github.com/gfx-rs/wgpu/issues/2519">this issue</a> for details.</p>
<h2 id="runtime-error-import--has-the-wrong-type"><a class="header" href="#runtime-error-import--has-the-wrong-type">Runtime error: import <code>...</code> has the wrong type</a></h2>
<p>This can occur when you have <code>.wasm</code> files in your <code>build</code> folder that are using an old version of the Ambient API.
Delete the <code>build</code> folder and try again - this should force them to be regenerated.</p>
<h2 id="failed-to-download-file--error-trying-to-connect-tcp-connect-error-etc-os-error-10060"><a class="header" href="#failed-to-download-file--error-trying-to-connect-tcp-connect-error-etc-os-error-10060">Failed to download file / error trying to connect: tcp connect error: <em>etc</em> (OS error 10060)</a></h2>
<p>This can happen if your anti-virus or firewall is blocking the connection to the Ambient runtime.
Try deactivating it, then run the Ambient package again with ‘ambient run’.</p>
<p>If this fixes it, you’ll need to add an exception to your anti-virus/firewall to allow Ambient to connect.
We do not recommend leaving your anti-virus/firewall disabled.</p>
<h2 id="ciso646-not-found"><a class="header" href="#ciso646-not-found"><code>&lt;ciso646&gt;</code> not found</a></h2>
<p>The compilation of <code>physx-sys</code> and other C++ libraries may fail due to a missing <code>ciso646</code> header.
This header was removed as part of C++20, and distributions no longer ship it by default.</p>
<p>This can be fixed on Debian-based distributions (i.e. Ubuntu 22.04, Pop!_OS 22.04, etc) by running</p>
<pre><code class="language-sh">sudo apt install libstdc++-12-dev
</code></pre>
<p>to install a version of the GNU C++ standard library that includes the header.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-installation-options"><a class="header" href="#advanced-installation-options">Advanced installation options</a></h1>
<p>For most users <a href="reference/../user/installing.html">the regular installation instructions</a> should suffice, but for more advanced setups the following options are available:</p>
<h2 id="installing-from-git"><a class="header" href="#installing-from-git">Installing from Git</a></h2>
<p>Ambient can be installed through <code>cargo install</code>.</p>
<p>This will automatically download the source, compile and install Ambient from your system. Our minimum supported Rust version is <!-- rust-version-begin -->1.70.0<!-- rust-version-end -->.</p>
<h3 id="installing-the-latest-published-release"><a class="header" href="#installing-the-latest-published-release">Installing the latest published release</a></h3>
<p>This is the recommended method of installing Ambient from source if the downloadable binaries are insufficient. The latest published release should be used unless you have a specific reason to use the development version.</p>
<pre><code class="language-sh">cargo install --git https://github.com/AmbientRun/Ambient.git --tag v0.3.2-dev ambient
</code></pre>
<h3 id="installing-the-latest-development-version"><a class="header" href="#installing-the-latest-development-version">Installing the latest development version</a></h3>
<p>Ambient is actively developed on the <code>main</code> branch of the repository. This branch contains in-development changes, including new features, bug fixes and breaking changes. This method can be used if you would like to try out these changes.</p>
<p><strong>Note</strong>: The <code>main</code> branch is subject to frequent breaking changes, including potential new bugs and decreased stability, and is not a stable development target for packages. Using the <code>main</code> branch is not recommended if you are unable to actively update your package to accommodate breaking changes.</p>
<pre><code class="language-sh">cargo install --git https://github.com/AmbientRun/Ambient.git --locked --force ambient
</code></pre>
<p><strong>Note</strong>: If you are running a package outside of the <code>guest/rust</code> workspace, it is likely that the published version of the API will be incompatible with <code>main</code>, and you will need to specify the dependency manually.</p>
<p>Additionally, the <code>--locked</code> flag is recommended to ensure that the correct packages are installed and that the build is reproducible between machines.</p>
<h3 id="optional-features"><a class="header" href="#optional-features">Optional features</a></h3>
<p>You can supply these feature flags to get optional features that are disabled by default:</p>
<pre><code class="language-sh">cargo install --git https://github.com/AmbientRun/Ambient.git ambient --features assimp --locked --force
</code></pre>
<ul>
<li><code>assimp</code>: This adds support for <a href="https://github.com/assimp/assimp">assimp</a>, which loads ~40 additional model file formats, such as <code>obj</code>, text-based <code>fbx</code> and much more</li>
</ul>
<h3 id="build-dependencies-linuxubuntu"><a class="header" href="#build-dependencies-linuxubuntu">Build dependencies: Linux/Ubuntu</a></h3>
<p>For the above to work on Linux, you also need to install the following build dependencies:</p>
<pre><code class="language-sh">apt-get install -y \
    build-essential cmake pkg-config \
    libfontconfig1-dev clang libasound2-dev ninja-build
</code></pre>
<h2 id="installing-via-asdf-linux-macos"><a class="header" href="#installing-via-asdf-linux-macos">Installing via asdf (Linux, Macos)</a></h2>
<p>Thanks to <a href="https://github.com/jtakakura">@jtakakura</a>, Ambient can also be installed using <a href="https://asdf-vm.com/">asdf</a> by running <code>asdf plugin add ambient</code>. For more details, visit <a href="https://github.com/jtakakura/asdf-ambient">https://github.com/jtakakura/asdf-ambient</a>.</p>
<h2 id="running-on-headless-linuxubuntu"><a class="header" href="#running-on-headless-linuxubuntu">Running on headless Linux/Ubuntu</a></h2>
<p>To run on a headless Linux machine, install the following dependencies in addition to the dependencies specified above:</p>
<pre><code class="language-sh">add-apt-repository ppa:oibaf/graphics-drivers -y
apt-get update
apt install -y libxcb-xfixes0-dev mesa-vulkan-drivers
</code></pre>
<p>Ambient currently assumes that you have access to GPU drivers (but not necessarily a GPU) in headless mode. This requirement may be relaxed in future.</p>
<h2 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h2>
<p>A <code>Dockerfile</code> is also provided that provides a headless Debian environment with all of the dependencies required to run Ambient as a server. This Dockerfile is intended for development, not production, so it has more dependencies than are strictly required to run Ambient.</p>
<p>To build the Dockerfile:</p>
<pre><code class="language-sh">docker build -t ambient .
</code></pre>
<p>To run the Dockerfile with <code>bash</code> in the current directory:</p>
<pre><code class="language-sh">docker run --rm -it -e bash -v &quot;$(pwd)&quot;:/app ambient
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="should-my-code-go-on-the-client-or-the-server"><a class="header" href="#should-my-code-go-on-the-client-or-the-server">Should my code go on the client or the server?</a></h2>
<p>The Ambient API is split into two parts: the client and the server. The client is the code that runs on the player’s machine, and the server is the code that runs on the host’s machine. The client is responsible for rendering the game, and for sending input to the server. The server is responsible for running the game simulation, and for sending the client information about the game state.</p>
<p>When you create a package, both <code>client</code> and <code>server</code> modules are created. You can put code in either of these modules, and it will be run on the client or the server, respectively. In general, code that runs on the server should be authoritative, and code that runs on the client should be visual. What the server says should be the source of truth for all players.</p>
<p>The ECS can be used to synchronize state between the server and the client. Both the client and the server have the same ECS, but components with the <code>Networked</code> attribute will be synchronized from the server to the client. The client can make its own changes to the ECS, including adding and modifying components, but any modified components will be overridden by the server’s version when the server sends an update for those components.</p>
<p>Additionally, both the client and the server can send structured messages to each other to communicate information that can’t be represented in the ECS. For more information on this, see the <a href="reference/./package.html#messages--messages">package documentation</a>.</p>
<p>Deciding where your code should go is important to making the most of Ambient, and it’s not always obvious. Here are some guidelines:</p>
<p>If you are doing any of the following, your code should go on the client:</p>
<ul>
<li>Rendering UI</li>
<li>Visual changes that should only be visible to the player</li>
<li>Capturing input</li>
<li>Playing sounds</li>
<li>Predicting the game state for better user experience</li>
<li>Visual effects that don’t need to be replicated exactly (particle systems, etc)</li>
</ul>
<p>If you are doing any of the following, your code should go on the server:</p>
<ul>
<li>Moving a character</li>
<li>Calculating damage</li>
<li>Spawning or updating entities</li>
<li>Changing the game state</li>
<li>Communicating with external services</li>
<li>Anything that should be authoritative</li>
<li>Anything that should be hidden from the player</li>
</ul>
<p>If you are doing any of the following, your code could go on either the client or the server, or be shared between them:</p>
<ul>
<li>Shared calculations (e.g. determining the color of a player’s nameplate from the player’s name)</li>
<li>Shared data structures</li>
<li>Shared constants</li>
<li>Shared utility functions</li>
<li>Shared types</li>
</ul>
<p>Consider looking at the game examples for more information on how to structure your code.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD041 -->
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<!-- markdownlint-disable-file MD024 -->
<p>This changelog is manually updated. While an effort will be made to keep the <a href="reference/changelog.html#unreleased-yyyy-mm-dd">Unreleased</a> changes up to date, it may not be fully representative of the current state of the project.</p>
<!-- If you are updating this file, make sure you copy the unreleased section and change the version and date. Do not remove it. -->
<!--
## Unreleased (YYYY-MM-DD)

### Added

#### Headline features

#### Other

### Changed

#### Breaking

#### Non-breaking

### Fixed

### Community PRs to internals

These PRs are not directly user-facing, but improve the development experience. They're just as appreciated!

### Removed
-->
<h2 id="version-031-2023-10-24"><a class="header" href="#version-031-2023-10-24">Version 0.3.1 (2023-10-24)</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<h4 id="headline-features"><a class="header" href="#headline-features">Headline features</a></h4>
<h4 id="other"><a class="header" href="#other">Other</a></h4>
<ul>
<li><strong>Package/<code>character_movement</code></strong>: <code>CharacterMovement</code> concept added.</li>
<li><strong>Assets</strong>: Added support for animations and skinning for assimp.</li>
<li><strong>Examples</strong>: Added assimp example.</li>
<li><strong>Examples</strong>: Added benchmark/animations example.</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<h4 id="breaking"><a class="header" href="#breaking">Breaking</a></h4>
<ul>
<li><strong>Server</strong>: The logging format has changed to increase consistency, remove unnecessary logs, and improve readability.</li>
<li><strong>API</strong>: <code>camera::world_to_screen</code> now returns a 3D vector instead of a 2D vector, which can be used to determine if the point is behind the camera.</li>
<li><strong>Packages</strong>: Renamed the <code>character_controller</code> package to <code>third_person_controller</code> and added a <code>ThirdPersonController</code> concept.</li>
</ul>
<h4 id="non-breaking"><a class="header" href="#non-breaking">Non-breaking</a></h4>
<ul>
<li><strong>Physics</strong>: The <code>Collision</code> message now includes the points of collision and their corresponding normals. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for fixing this in <a href="https://github.com/AmbientRun/Ambient/pull/1107">#1107</a>!</li>
<li><strong>Pipeline Types</strong>: A few extra types have been exported. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for fixing this in <a href="https://github.com/AmbientRun/Ambient/pull/1082">#1082</a>!</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li><strong>Debugger</strong>: The debugger has now been re-enabled.</li>
<li><strong>CLI</strong>: Released <code>crates.io</code> versions are now used as the API dependency in a new project instead of git tags of the Ambient repository.</li>
<li><strong>Rendering</strong>: Fixed 3D line drawing when they’re behind the camera.</li>
<li><strong>Networking</strong>: The send queue is now compacted during send to reduce queue growth when backlogged by a slow player connection.</li>
<li><strong>Web</strong>: The web client will now update its size when the window is resized.</li>
<li><strong>Rendering</strong>: Fixed an issue where a black border would appear around solid objects with an alpha cutoff (<a href="https://github.com/AmbientRun/Ambient/pull/1104">#1104</a>).</li>
<li><strong>Rendering</strong>: Fixed water not working on the web.</li>
<li><strong>Package/<code>orbit_camera</code></strong>: Scrolling the ECS inspector will no longer zoom the camera in and out.</li>
</ul>
<h3 id="community-prs-to-internals"><a class="header" href="#community-prs-to-internals">Community PRs to internals</a></h3>
<p>These PRs are not directly user-facing, but improve the development experience. They’re just as appreciated!</p>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<h2 id="version-030-2023-10-04"><a class="header" href="#version-030-2023-10-04">Version 0.3.0 (2023-10-04)</a></h2>
<p>This release involved a great many changes, including porting Ambient to the web, adding support for deployments, many API changes, and more. Not all changes may be reflected in this changelog; please let us know if you find any omissions.</p>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<h4 id="headline-features-1"><a class="header" href="#headline-features-1">Headline features</a></h4>
<ul>
<li><strong>Client</strong>: The client can now <strong>run on the web</strong>.</li>
<li><strong>Deploy</strong>: The <code>ambient deploy</code> command can now be used to deploy a package to Ambient runtime services.</li>
<li><strong>Audio</strong>: Spatial audio is now supported for 3D sounds. See the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/physics/basics/src/client.rs">physics example</a> and <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/controllers/first_person_camera/src/client.rs">first_person_camera example</a></li>
<li><strong>Networking</strong>: The networking protocol now supports WebTransport for the web client.</li>
<li><strong>Rendering</strong>: Procedural meshes, textures, samplers and materials are now supported on the client. See the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/rendering/procedural_generation">procedural generation example</a>.</li>
<li><strong>Semantics</strong>: A semantic system to connect packages (previously projects) has been added. This enables dependencies, enums and more. See the breaking changes for more details.</li>
</ul>
<h4 id="other-1"><a class="header" href="#other-1">Other</a></h4>
<ul>
<li><strong>UI</strong>: Added a new <code>ImageFromUrl</code> element, which can load images from assets or URLs. It also supports rounded corners, borders and a fallback background color. See the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/ui/image/src/client.rs">image example</a> for more details.</li>
<li><strong>Rendering</strong>: Added a <code>torus</code> primitive. Thanks to <a href="https://github.com/mebyz">@mebyz</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/376">#376</a>!</li>
<li><strong>Physics</strong>: Add <code>set_character_controller_position</code> to the <code>physics</code> API. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/398">#398</a>.</li>
<li><strong>ECS</strong>: <code>Duration</code> is now a supported primitive type.</li>
<li><strong>ECS</strong>: All integer types from 8-bit to 64-bit are now supported as component types, including signed and unsigned variants. Additionally, all signed and unsigned integer vector types are now supported. This includes <code>U16</code>, <code>IVec2</code>, <code>UVec3</code>, etc.</li>
<li><strong>Docs</strong>: The IDE documentation has been improved, including information on how to set up Emacs for Ambient development (thanks to <a href="https://github.com/kevzettler">@kevzettler</a> in <a href="https://github.com/AmbientRun/Ambient/pull/505">#505</a>).</li>
<li><strong>Assets</strong>: <code>ambient assets import</code> can be used to import assets one by one. This will create or modify the <code>pipeline.toml</code> file for you.</li>
<li><strong>Camera</strong>: Added <code>camera::get_active</code> to get the active camera.</li>
<li><strong>Client</strong>: When using the native client, you can now use <code>--window-x</code> and <code>--window-y</code> to specify the window position, as well as <code>--window-width</code> and <code>--window-height</code> to specify the window size.</li>
<li><strong>Packages</strong>: A set of standard packages have been added. Explore <code>guest/rust/packages</code> to find them. These include a character controller, a focus-grabber, a package manager, and more.</li>
<li><strong>Packages</strong>: Several sample games have been added, including <code>tangent</code>, <code>arkanoid</code>, <code>pong</code>, and more.</li>
<li><strong>Examples</strong>: Examples have been added for new functionality, including <code>clock</code>, <code>audio_ctrl</code>, <code>dependencies</code>, and more.</li>
<li><strong>Debugging</strong>: Sentry has been added to the client and server to automatically report crashes. This can be disabled in Ambient’s <code>settings.toml</code>.</li>
</ul>
<h4 id="breaking-1"><a class="header" href="#breaking-1">Breaking</a></h4>
<ul>
<li>
<p><strong>Examples</strong>: Examples have been rearranged to be more discoverable. They are now grouped by category.</p>
</li>
<li>
<p><strong>Project</strong>: Projects have been renamed to Packages; see the <a href="https://ambientrun.github.io/Ambient/reference/package.html">package documentation</a> for details.</p>
</li>
<li>
<p><strong>Package</strong>: As mentioned above, a new package semantic system has been added. This comes with several breaking changes:</p>
<ul>
<li>
<p>In your Rust code:</p>
<ul>
<li>The modules generated by the Ambient macro are now different in shape. They are namespaced, with each item being present in the namespace as a separate module within the <code>packages</code> module, where your package is <code>this</code>. For example:
<ul>
<li><code>components::my_component</code> -&gt; <code>packages::this::components::my_component</code></li>
<li><code>ambient_api::components::core::app::main_scene</code> -&gt; <code>ambient_api::core::app::components::main_scene</code></li>
<li>a dependency <code>cool_dependency = { path = &quot;somewhere&quot; }</code> -&gt; <code>packages::cool_dependency::components::my_component</code> (i.e. the name used for the import is used, not the package ID)</li>
</ul>
</li>
<li><code>asset::url</code> has been removed; instead, each package now introduces an <code>assets</code> module, allowing you to access that package’s assets directly. For example:
<ul>
<li><code>asset::url(&quot;assets/Teapot.glb&quot;).unwrap()</code> -&gt; <code>packages::ambient_example_asset_loading::assets::url(&quot;Teapot.glb&quot;)</code></li>
</ul>
</li>
<li>UI layout components now use enums to specify their alignment. For example:
<ul>
<li><code>with_default(fit_vertical_none())</code> -&gt; <code>with(fit_vertical(), Fit::None)</code></li>
</ul>
</li>
<li>Messages now preserve the order of their fields.
<ul>
<li>If your fields are <code>a, c, b</code>, they will be in that order in the generated code.</li>
<li>Previously, they were sorted alphabetically.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>In your <code>ambient.toml</code>:</p>
<ul>
<li>
<p>Specifying a <code>version</code> is now mandatory.</p>
</li>
<li>
<p>Specifying a <code>content</code> is now mandatory.</p>
</li>
<li>
<p>Messages now have PascalCase IDs:</p>
<ul>
<li><code>messages.set_controller</code> -&gt; <code>messages.SetController</code></li>
</ul>
</li>
<li>
<p>Enums are now supported; they are defined as follows, and can be used anywhere a primitive type can be used, including components and messages.</p>
<pre><code class="language-toml">[enums.Layout]
description = &quot;The type of the layout to use.&quot;
[enums.Layout.members]
Flow = &quot;Bottom-up flow layout.&quot;
Dock = &quot;Top-down dock layout.&quot;
Bookcase = &quot;Min-max bookcase layout.&quot;
WidthToChildren = &quot;Width to children.&quot;

[components]
layout = { type = &quot;Layout&quot; }
</code></pre>
</li>
<li>
<p>Packages can now depend on other packages, allowing for access to their components, messages, etc. This is done by adding a <code>dependencies</code> section to your package. For example:</p>
<pre><code class="language-toml">[dependencies]
my_cool_package = { path = &quot;cool_package&quot; }
</code></pre>
<p>This will allow you to access the components, messages, etc. of the <code>my_cool_package</code> package from your package. The name that you use to import the package will be used as the namespace, not the package’s original ID.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Components</strong>: Several “tag components” have been prefixed with <code>is_</code> to indicate their tag nature. These include:</p>
<ul>
<li><code>core::animation::animation_player</code> -&gt; <code>core::animation::is_animation_player</code></li>
<li><code>core::audio::audio_player</code> -&gt; <code>core::audio::is_audio_player</code></li>
<li><code>core::audio::spatial_audio_player</code> -&gt; <code>core::audio::is_spatial_audio_player</code></li>
<li><code>core::layout::screen</code> -&gt; <code>core::layout::is_screen</code></li>
<li><code>core::network::persistent_resources</code> -&gt; <code>core::network::is_persistent_resources</code></li>
<li><code>core::network::synced_resources</code> -&gt; <code>core::network::is_synced_resources</code></li>
<li><code>core::player::player</code> -&gt; <code>core::player::is_player</code></li>
<li><code>core::wasm::module</code> -&gt; <code>core::wasm::is_module</code></li>
<li><code>core::wasm::module_on_server</code> -&gt; <code>core::wasm::is_module_on_server</code></li>
</ul>
</li>
<li>
<p><strong>API</strong>: Locally-broadcasted messages can now choose to include the originating module in the broadcast; this is an additional boolean parameter to <code>ModuleMessage::send_local_broadcast</code> and <code>message::Target::LocalBroadcast</code>.</p>
</li>
<li>
<p><strong>Camera</strong>: Renamed <code>screen_to_world_direction</code> to <code>screen_position_to_world_ray</code> and <code>clip_space_ray</code> to <code>clip_position_to_world_ray</code>. See <a href="https://github.com/AmbientRun/Ambient/issues/410">#410</a>.</p>
</li>
<li>
<p><strong>Package</strong>: <code>type = { type = &quot;Vec3&quot; }</code> is no longer valid syntax in <code>ambient.toml</code>. Only <code>type = &quot;Vec3&quot;</code> and <code>type = { type = &quot;Vec&quot;, element-type = &quot;Vec3&quot; }</code> are valid.</p>
</li>
<li>
<p><strong>Physics</strong>: Renamed the <code>visualizing</code> component to <code>visualize_collider</code>.</p>
</li>
<li>
<p><strong>Animation</strong>: The animation system has been reworked. See the <a href="https://ambientrun.github.io/Ambient/reference/animations.html">animation documentation</a> for details. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for laying the foundation for this!</p>
</li>
<li>
<p><strong>Physics</strong>: Renamed <code>box_collider</code> to <code>cube_collider</code>.</p>
</li>
<li>
<p><strong>API</strong>: The <code>time</code> function has been split into <code>game_time</code> and <code>epoch_time</code>. The <code>dtime</code> component has been renamed to <code>delta_time</code>. The <code>frametime</code> function has been renamed to <code>delta_time</code>.</p>
</li>
<li>
<p><strong>Assets</strong>: Asset pipelines now use TOML instead of JSON. Use the <code>ambient assets migrate-pipelines-toml</code> command to migrate. (Note that this command will be removed in the next release.)</p>
</li>
<li>
<p><strong>API</strong>: Removed <code>Entity::with_default</code> due to its confusing behaviour (Rust defaults are not necessarily the same as component or concept defaults). You will now have to explicitly specify a value for each component.</p>
</li>
<li>
<p><strong>API</strong>: <code>entity::wait_for_component</code> is now marked as <code>must_use</code> to ensure users consider the possibility of the entity being despawned.</p>
</li>
<li>
<p><strong>Elements</strong>: All hooks are now free functions (i.e. <code>use_state(hooks, ..)</code> instead of <code>hooks.use_state(..)</code>)</p>
</li>
<li>
<p><strong>UI</strong>: Focus is now global across different packages, including the removal of the <code>FocusRoot</code> element component.</p>
</li>
<li>
<p><strong>Hierarchies</strong>: The <code>children</code> component is now automatically derived from <code>parent</code> components (unless the user opts out of this). The <code>children</code> component is also no longer networked, as it is automatically derived on the client.</p>
</li>
<li>
<p><strong>Concepts</strong>: Concept code generation has been changed to generate <code>structs</code> instead, as well as adding support for optional components. See the documentation for more information.</p>
</li>
</ul>
<h4 id="non-breaking-1"><a class="header" href="#non-breaking-1">Non-breaking</a></h4>
<ul>
<li><strong>Logging</strong>: The logging output levels have been tweaked to better communicate the state of the system at any given time.</li>
<li><strong>Debugger</strong>: The debugger has been improved with a resizable sidebar, a scrollable view, and a component filter.</li>
<li><strong>Animation</strong>: The animation graph is now executed on the server as well.</li>
<li><strong>CLI</strong>: The <code>ambient new</code> command now takes several parameters to customize the resulting generation.</li>
<li><strong>Rendering</strong>: The renderer now runs using the direct pipeline on all architectures. This is temporary until platform-specific issues with the multi-draw indirect pipeline are addressed.</li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li><strong>Rendering</strong>: Skinned meshes will no longer be corrupted when there is more than one skinned mesh in a mesh buffer.</li>
<li><strong>UI</strong>: <code>TextEditor</code> will no longer capture input even when it is not visible.</li>
<li><strong>Rendering</strong>: Decals now render more consistently.</li>
<li><strong>API</strong>: <code>entity::wait_for_component</code> will now exit if the entity is despawned.</li>
<li><strong>API</strong>: The <code>message::Source</code> methods no longer consume the source when returning their data.</li>
<li><strong>Rendering</strong>: Lines with a <code>from</code> located after a <code>to</code> on the X-dimension will now render correctly.</li>
<li><strong>API</strong>: The <code>entity::mutate_component</code> documentation now refers to the correct parameter. Thanks to <a href="https://github.com/aldzban">@aldzban</a> for fixing this in <a href="https://github.com/AmbientRun/Ambient/pull/482">#482</a>.</li>
<li><strong>UI</strong>: The <code>ScrollArea</code> now has a scroll bar.</li>
<li><strong>Input</strong>: Input is now cleared when the window loses focus, preventing “stuck input” bugs.</li>
<li><strong>UI</strong>: Layout-related properties, like alignment and fit, did not work correctly for certain values. This has been fixed with the introduction of enums.</li>
<li><strong>Player</strong>: Player entities are now recursively despawned when disconnecting.</li>
<li><strong>Build</strong>: Rust compilation errors are now more readable with more colors and fewer unused warnings.</li>
<li><strong>ECS</strong>: The <code>transformable</code> concept now includes <code>local_to_world</code> to ensure that the world transform is always available.</li>
<li><strong>Physics</strong>: The <code>physics::raycast[_first]</code> functions will now validate the direction to ensure that they are non-zero, non-NaN and normalized.</li>
<li><strong>Rendering</strong>: Removing the <code>outline_recursive</code> component from a entity will now remove the outline from its children as well.</li>
<li><strong>API</strong>: The <code>ambient_ui</code> prelude (and the <code>ambient_api</code> prelude, by extension) no longer glob-imports components into the global namespace. This means that you will need to import components explicitly.</li>
<li><strong>Messaging</strong>: Messages without empty fields now generate a unit struct, instead of a struct with no fields. That is, they generate <code>struct MyMessage;</code> instead of <code>struct MyMessage {}</code>.</li>
<li><strong>Physics</strong>: Child collision volumes are now automatically updated when their parent’s transform changes. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for fixing this in <a href="https://github.com/AmbientRun/Ambient/pull/885">#885</a>!</li>
</ul>
<h3 id="community-prs-to-internals-1"><a class="header" href="#community-prs-to-internals-1">Community PRs to internals</a></h3>
<p>These PRs are not directly user-facing, but improve the development experience. They’re just as appreciated!</p>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><code>glam</code> was updated to 0.24. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/434">#434</a>.</li>
</ul>
<h3 id="removed-1"><a class="header" href="#removed-1">Removed</a></h3>
<h2 id="version-021-2023-05-06"><a class="header" href="#version-021-2023-05-06">Version 0.2.1 (2023-05-06)</a></h2>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li><strong>API</strong>: The API documentation is now built only for the <code>wasm</code> target on <code>docs.rs</code>.</li>
</ul>
<h2 id="version-020-2023-05-05"><a class="header" href="#version-020-2023-05-05">Version 0.2.0 (2023-05-05)</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<h4 id="headline-features-2"><a class="header" href="#headline-features-2">Headline features</a></h4>
<ul>
<li><strong>API</strong>: Guest code can now <strong>create and interact with UI</strong>. See <a href="https://github.com/AmbientRun/Ambient/tree/v0.2.0/guest/rust/examples/ui">the UI examples</a>.</li>
<li><strong>API</strong>: Guest code can now <strong>run on the client</strong>. See <a href="https://github.com/AmbientRun/Ambient/tree/v0.2.0/guest/rust/examples/basics/clientside">the <code>clientside</code> example</a>.</li>
<li><strong>API</strong>: Clientside guest code can now play <strong>basic audio</strong>. See <a href="https://github.com/AmbientRun/Ambient/tree/v0.2.0/guest/rust/examples/games/pong">the <code>pong</code> example</a>.</li>
<li><strong>Server</strong>: By default, a proxy URL is generated for the server on startup. This can be used to access a running server from anywhere on the internet, making it easy to share your work with others. To turn this off, specify <code>--no-proxy</code> on the server command line.</li>
</ul>
<h4 id="other-2"><a class="header" href="#other-2">Other</a></h4>
<ul>
<li><strong>API</strong>: Kinematic bodies are now exposed. This is used by the minigolf example to provide its moving obstacles.</li>
<li><strong>API</strong>: Added <code>physics::move_character</code> function to correctly move character controllers. This is used by the third-person camera example.</li>
<li><strong>API</strong>: <code>Uvec2</code>/<code>Uvec3</code>/<code>Uvec4</code>/<code>U8</code> can now be used for component values.</li>
<li><strong>API</strong>: A new <code>message</code> API has been added to allow for sending messages between client and server WASM, and from one WASM module to another. Messages are defined in <code>ambient.toml</code> and are structured. Message subscriptions return handles that can be used to cancel their subscriptions.</li>
<li><strong>API</strong>: A new <code>camera</code> API has been added on the client for operations that involve the camera, including <code>screen_ray</code> for calculating a ray from the camera through a screen position. Thanks to <a href="https://github.com/owenpalmer">@owenpalmer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/316">#316</a>.</li>
<li><strong>API</strong>: A new <code>input</code> API has been added for retrieving input and manipulating the cursor (including changing its icon, visibility and lock state).</li>
<li><strong>API</strong>: <code>physics::{add_impulse, add_force_at_position, add_impulse_at_position, get_velocity_at_position}</code> have been added.</li>
<li><strong>API</strong>: Added <code>create_revolute_joint</code> to the <code>physics</code> API.</li>
<li><strong>API</strong>: Added a capsule concept with corresponding components.</li>
<li><strong>API</strong>: Several animation manipulation functions have been added to <code>entity</code> and <code>asset</code>. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/362">#362</a>.</li>
<li><strong>Physics</strong>: A <code>collider_loaded</code> component will now be automatically attached to an entity once its collider has finished loading.</li>
<li><strong>Client</strong>: The client’s window title is now automatically changed to the name of the project running on the server. Thanks to <a href="https://github.com/MavethGH">@MavethGH</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/178">#178</a>.</li>
<li><strong>Client</strong>: Added a basic headless mode to enable automatic CI testing of projects.</li>
<li><strong>Client</strong>: Added <code>Dump UI World</code> button to inspect the state of the UI. Thanks to <a href="https://github.com/owenpalmer">@owenpalmer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/216">#216</a>.</li>
</ul>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<ul>
<li>A suite of UI examples have been added to demonstrate how to use the UI in guest code.</li>
<li>The <code>clientside</code> example shows how to use clientside WASM.</li>
<li>The <code>messaging</code> example shows how to message the server from the client and vice versa, and how to message another module with both broadcasts and directed messages.</li>
<li>The <code>pong</code> example implements a basic version of Pong to demonstrate a basic multiplayer game.</li>
<li>The <code>fog</code> example shows how to configure fog in the renderer for more atmospheric scenes.</li>
<li>The <code>first_person_camera</code> example shows how to implement a first-person camera.</li>
<li>The <code>music_sequencer</code> example shows how to use the audio and UI API to build a basic music sequencer.</li>
<li>The <code>decals</code> example shows how to use decals to add detail to a scene. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/347">#347</a>.</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<h4 id="breaking-2"><a class="header" href="#breaking-2">Breaking</a></h4>
<ul>
<li><strong>Client</strong>: <code>--debug</code> is now <code>--debugger</code>, but it can also be accessed through the <code>AMBIENT_DEBUGGER</code> env variable.</li>
<li><strong>API</strong>: The <code>Cargo.toml</code> has changed to enable clientside builds. Please look at the examples to see how to update your <code>Cargo.toml</code> appropriately.</li>
<li><strong>API</strong>: <code>ChangeQuery</code> has been split into <code>UntrackedChangeQuery</code> and <code>ChangeQuery</code> to ensure that <code>track_change</code> is called before the query is built.</li>
<li><strong>API</strong>: <code>asset_url</code> has moved to <code>asset::url</code>.</li>
<li><strong>API</strong>: <code>EventResult</code> and <code>EventOk</code> have been renamed to <code>ResultEmpty</code> and <code>OkEmpty</code> to better clarify their purpose.</li>
<li><strong>API</strong>: The physics API has been revamped to better encode the physics engine’s capabilities.
<ul>
<li><code>physics::apply_force</code> is now <code>physics::add_force</code>.</li>
<li><code>physics::explode_bomb</code> is now <code>physics::add_radial_impulse</code>, and takes a <code>FalloffRadius</code> enum.</li>
</ul>
</li>
<li><strong>API</strong>: All input functionality has moved to <code>input</code> on the clientside.</li>
<li><strong>API</strong>: The <code>lookat_center</code> component has been renamed to <code>lookat_target</code>.</li>
<li><strong>Physics</strong>: Convex shapes are now used if a body is neither static or kinematic.</li>
</ul>
<h4 id="non-breaking-2"><a class="header" href="#non-breaking-2">Non-breaking</a></h4>
<ul>
<li><strong>Ambient</strong>: Ambient is now dual-licensed MIT/Apache2, in accordance with the rest of the Rust ecosystem.</li>
<li><strong>Ambient</strong>: The default logging settings now better communicate what Ambient is doing at any given moment.</li>
<li><strong>Project</strong>: Concept definitions in projects now support namespaces. Thanks to <a href="https://github.com/ArberSephirotheca">@ArberSephirotheca</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/212">#212</a>.</li>
<li><strong>API</strong>: Concepts now include the components they use in their doc comments.</li>
<li><strong>API</strong>: <code>#[main]</code>-attributed functions no longer have to be <code>async</code> or return a <code>Result</code>.</li>
<li><strong>API</strong>: <code>#[main]</code>-attributed functions, <code>on</code>, <code>once</code>, <code>Query::bind</code> and <code>run_async</code> can now return a <code>Result</code> or nothing.</li>
<li><strong>Project</strong>: Project manifests can now be split into multiple files using <code>includes</code>.</li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li><strong>Ambient</strong>: Various stability and performance fixes.</li>
<li><strong>Ambient</strong>: Added attributions for external code.</li>
<li><strong>Ambient</strong>: Typo fixes. Thanks for the following!
<ul>
<li><a href="https://github.com/AmbientRun/Ambient/pull/159">#159: fix: docs broken links to gh-pages</a> by <a href="https://github.com/daniellavoie">@daniellavoie</a></li>
<li><a href="https://github.com/AmbientRun/Ambient/pull/172">#172: chore: fix typo in gpu.rs</a> by <a href="https://github.com/eltociear">@eltociear</a></li>
</ul>
</li>
<li><strong>Examples</strong>: The Minigolf example now has several gameplay tweaks (including camera movement on right-click) to improve the experience.</li>
<li><strong>Examples</strong>: The examples no longer occasionally use non-one alpha colours, which led to them rendering black objects.</li>
<li><strong>Server</strong>: The server no longer shuts down automatically after a period of inactivity.</li>
<li><strong>ECS</strong>: A bug with ECS component versioning that led to certain components not updating has been fixed. Fixes <a href="https://github.com/AmbientRun/Ambient/issues/113">#113</a>.</li>
<li><strong>Networking</strong>: Various optimizations have been made to networking and the ECS to reduce unnecessary network traffic.</li>
</ul>
<h3 id="community-prs-to-internals-2"><a class="header" href="#community-prs-to-internals-2">Community PRs to internals</a></h3>
<p>These PRs are not directly user-facing, but improve the development experience. They’re just as appreciated!</p>
<ul>
<li><strong>CI</strong>: Linux CI builds now output the tree of their target to assist in debugging CI cache blow-up. Thanks to <a href="https://github.com/daniellavoie">@daniellavoie</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/170">#170</a>.</li>
<li><strong>ECS</strong>: <code>Entity::assert_all</code> can be used to ensure all components for an <code>Entity</code> on the host have an attribute. Thanks to <a href="https://github.com/MavethGH">@MavethGH</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/211">#211</a>.</li>
<li><strong>App</strong>: <code>ambient new</code> uses the correct path for relative API when creating a project in <code>guest/rust/examples</code>. Thanks to <a href="https://github.com/owenpalmer">@owenpalmer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/218">#218</a>.</li>
<li><strong>Ambient</strong>: The presentation of the license in the repository was improved. Thanks to <a href="https://github.com/C-BJ">@C-BJ</a> for <a href="https://github.com/AmbientRun/Ambient/pull/201">#201</a> and <a href="https://github.com/AmbientRun/Ambient/pull/203">#203</a>.</li>
<li><strong>Ambient</strong>: The book and build CI workflows now only run when relevant files are updated. Thanks to <a href="https://github.com/C-BJ">@C-BJ</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/202">#202</a>.</li>
<li><strong>Audio</strong>: The audio asset pipeline now uses Rust libraries for re-encoding files, instead of shelling out to ffmpeg. Thanks to <a href="https://github.com/marceline-cramer">@marceline-cramer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/317">#317</a>.</li>
<li><strong>Rendering</strong>: Ambient now runs on wgpu 0.16, improving compatibility and providing access to new features. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/308">#308</a>.</li>
<li><strong>Campfire</strong>: The internal development tool Campfire can now automatically check release-readiness. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/356">#356</a>.</li>
</ul>
<h3 id="removed-2"><a class="header" href="#removed-2">Removed</a></h3>
<ul>
<li><strong>API</strong>: <code>player_camera</code> has been removed, and the components it instantiated are now directly exposed. See the <code>multiplayer</code> example to see what’s changed.</li>
<li><strong>API</strong>: Events have been removed and replaced with the more general-purpose <code>message</code> API.</li>
</ul>
<h2 id="version-011-2023-02-22"><a class="header" href="#version-011-2023-02-22">Version 0.1.1 (2023-02-22)</a></h2>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>A <a href="https://github.com/AmbientRun/Ambient/tree/v0.1.1/guest/rust/examples/minigolf">minigolf example</a> by <a href="https://github.com/SK83RJOSH">SK83RJOSH</a>.</li>
<li>Examples are now bundled into a downloadable <code>examples.zip</code> for each release.</li>
</ul>
<h3 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h3>
<ul>
<li>macOS ARM64 builds are now available after enabling the execution of unsigned executable memory (as required for wasmtime execution).</li>
<li>The debugging configuration for VSCode was updated to use the new CLI.</li>
<li>Minor documentation updates.</li>
</ul>
<h2 id="version-010-2023-02-22"><a class="header" href="#version-010-2023-02-22">Version 0.1.0 (2023-02-22)</a></h2>
<p>Initial release. See the <a href="https://www.ambient.run/post/introducing-ambient">announcement blog post</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-internals"><a class="header" href="#runtime-internals">Runtime internals</a></h1>
<p>This part of the documentation covers how the runtime works internally,
and how you can make changes to it. This is primarily for those who want to contribute
to the Ambient repository itself; most end-users should not need to read this.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h2>
<p>To make changes to the runtime itself, start with cloning this repository:</p>
<pre><code class="language-sh">git clone git@github.com:AmbientRun/Ambient.git
</code></pre>
<p>If you use VSCode, we then recommend opening two instance of it; one in the
root, and one in <code>guest/rust</code>. This is because <code>guest/rust</code> has a different
target architecture (WASM), so a separate <code>rust-analyzer</code> instance is required
to ensure the workspaces function correctly.</p>
<h2 id="running-examples-from-main-as-a-developer"><a class="header" href="#running-examples-from-main-as-a-developer">Running examples from <code>main</code> as a developer</a></h2>
<p>If you are a developer actively working on Ambient, you can run the examples from the <code>guest/rust/examples</code> directory directly, without having to install Ambient.</p>
<ol>
<li>Clone the GitHub repository.</li>
<li>Run the examples in the <code>guest/rust/example</code> directory: <code>cargo run --release -- guest/rust/examples/basics/primitives</code></li>
</ol>
<p>To help with this, the Ambient repository has a tool called <a href="runtime_internals/../runtime_internals/contributing.html#campfire">Campfire</a>.
It offers a convenient way to run examples:</p>
<pre><code class="language-sh">cargo cf run -r primitives
</code></pre>
<p>The name is based on the end of the path, so additional context can be provided if necessary:</p>
<pre><code class="language-sh">cargo cf run -r basics/primitives
</code></pre>
<h2 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency graph</a></h2>
<p><img src="runtime_internals/dependency_graph.png" alt="Dependency graph" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>We welcome community contributions to this project.</p>
<p>Please talk with us <a href="https://discord.gg/ambient">on Discord</a> beforehand if you’d like to contribute a larger piece of work. This is particularly important if your contribution involves adding new functionality to the host; our goal is to implement as much functionality on the guest as possible, so that the host can remain simple and enable a wide variety of use cases without being too opinionated.</p>
<h2 id="campfire"><a class="header" href="#campfire">Campfire</a></h2>
<p>Campfire is our internal tool for working with the repository. It has several commands that can be used to help with development, which you can find by running <code>cargo campfire --help</code>.</p>
<p>It is also aliased to <code>cargo cf</code> for convenience.</p>
<p>Running an example can be done like this:</p>
<pre><code class="language-sh">cargo cf run decals
</code></pre>
<p>By default, Campfire will build Ambient with the <code>debug</code> profile. To build with the <code>release</code> profile and to build the assets with <code>--release</code>, use the <code>--release</code> flag before the example and after:</p>
<pre><code class="language-sh">cargo cf run --release decals -- --release
</code></pre>
<h2 id="api-docs"><a class="header" href="#api-docs">API docs</a></h2>
<p>To see the latest version of the API docs, run the following command in the <code>Ambient</code> repository:</p>
<pre><code class="language-sh">cargo campfire doc api --open
</code></pre>
<h2 id="installing-1"><a class="header" href="#installing-1">Installing</a></h2>
<p>As a developer, you may find yourself needing to install (a specific version of) Ambient on your system. This can be done with the following command:</p>
<pre><code>cargo campfire install [--git-revision &lt;revision&gt;] [--git-tag &lt;tag&gt;] [--suffix &lt;suffix&gt;]
</code></pre>
<p>If no revision or tag is specified, the version of Ambient in the current directory will be installed as <code>ambient-dev</code>. Otherwise, if specified, the relevant version will be suffixed to the executable’s name by default:</p>
<pre><code class="language-sh">cargo campfire install --git-tag v0.1.0
</code></pre>
<p>This will install Ambient 0.1 as <code>ambient-v0.1.0</code>.</p>
<p>A custom suffix can be specified with the <code>--suffix</code> flag, and will override any suffix that would otherwise be used:</p>
<pre><code class="language-sh">cargo campfire install --git-tag v0.1.0 --suffix back-in-time
</code></pre>
<p>This will install Ambient 0.1 as <code>ambient-back-in-time</code>.</p>
<h2 id="adding-to-the-api"><a class="header" href="#adding-to-the-api">Adding to the API</a></h2>
<p>Our bindings are defined in <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md">WIT</a>, which is a language-independent interface definition language for defining WebAssembly interfaces.
They are found in the <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/wit"><code>crates/wasm/wit</code></a> folder.
At present, there is only one WIT world, <code>bindings</code>, in the <code>main.wit</code> folder, and it is used for both the client and server bindings.</p>
<p>These bindings are wired up in the host using <a href="https://docs.wasmtime.dev/api/wasmtime/component/index.html"><code>wasmtime</code>’s Component Model support</a>.
The WIT interfaces generate traits, which are then implemented within <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/src/client/mod.rs">crates/wasm/src/client/mod.rs</a> and <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/src/server/mod.rs">crates/wasm/src/server/mod.rs</a>. As all interfaces need to be implemented - even when not relevant to the side of the network boundary you’re on - unused implementations go in the <code>unused.rs</code> module in the same folder.</p>
<p>Types that are shared between interfaces should go in <code>types.wit</code>; otherwise, they should go in the relevant interface file. Where possible, try to describe as much within the WIT files; the more that is specified in the WIT files, the less code needs to be written for each guest language.</p>
<p>If you add a new interface, you will need to expose it in <code>main.wit</code>, update <code>crates/wasm/src/shared/bindings.rs</code> to include it in <code>BindingsBound</code>, and add implementations for the new trait in <code>crates/wasm/src/client/mod.rs</code> and <code>crates/wasm/src/server/mod.rs</code>.</p>
<p>On the host, add implementations of <code>IntoBindgen</code> and <code>FromBindgen</code> for your WIT type. This is typically done in a <code>conversion.rs</code>. This allows you to use the type in the host code with the usual affordances, while still being able to pass it to the guest.</p>
<h3 id="guest-considerations"><a class="header" href="#guest-considerations">Guest considerations</a></h3>
<p>At present, we only support Rust as a guest language, but we want to improve this in future. The following advice applies only to Rust.</p>
<hr />
<p>The WIT bindings are automatically generated by the host’s <code>ambient_wasm</code> build script. This build script runs <a href="https://github.com/bytecodealliance/wit-bindgen"><code>wit-bindgen</code></a> as a library and updates <code>guest/rust/api_core/src/internal/bindings.rs</code> with the generated code. You may need to build the host in order to update the guest API code after making changes to the WIT files, but running <code>cargo check</code> (including through your IDE on save) should be sufficient to trigger this process.</p>
<p>When merging code that changes the bindings, there may be a conflict in the generated <code>bindings.rs</code> file. In this case, delete the file and run <code>cargo check -p ambient_wasm</code> (or a similar command that will run <code>ambient_wasm</code>’s build script) to force regeneration of the file.</p>
<p>Where relevant/possible, use native types and convert to/from the WIT types with <code>IntoBindgen</code>/<code>FromBindgen</code>. This allows both API developers and users to use the type they would expect (e.g. <code>glam::Vec3</code> instead of the WIT-generated <code>Vec3</code>), and to extend it with additional methods where required.</p>
<p>This means that if you define a</p>
<pre><code class="language-wit">record ray {
    origin: vec3,
    direction: vec3,
}
</code></pre>
<p>you should also consider defining</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Some documentation
struct Ray {
    // Per-field
    origin: Vec3,
    // Documentation
    direction: Vec3,
}
impl IntoBindgen for Ray {
    type Item = wit::types::Ray;
    fn into_bindgen(self) -&gt; Self::Item {
        wit::types::Ray {
            origin: self.origin.into_bindgen(),
            direction: self.direction.into_bindgen(),
        }
    }
}
impl FromBindgen for wit::types::Ray {
    type Item = Ray;
    fn from_bindgen(self) -&gt; Self::Item {
        Ray {
            origin: self.origin.from_bindgen(),
            direction: self.direction.from_bindgen(),
        }
    }
}
impl Ray {
    /* helper methods */
}
<span class="boring">}
</span></code></pre></pre>
<p>so that you can provide Rust-specific features. Where possible, try to avoid exposing the WIT types to the user, and try to keep as much functionality in WIT to ensure other guest languages can benefit from it.</p>
<h2 id="adding-a-new-supported-component-type"><a class="header" href="#adding-a-new-supported-component-type">Adding a new supported component type</a></h2>
<p>Components and their values are the core unit of data exchange in Ambient. We try to keep to a core set of types as adding more types results in some amount of bloat (especially with the amount of code generated); however, adding a new type is often the best way to represent a specific kind of data.</p>
<p>To do so, you will need to update the following files:</p>
<h3 id="core-definitions"><a class="header" href="#core-definitions">Core definitions</a></h3>
<ul>
<li><code>crates/wasm/wit/component.wit</code>: Add the new type to the three <code>value</code> enums.</li>
<li><code>shared_crates/shared_types/src/lib.rs</code>: Add the new type to the <code>primitive_component_definitions</code> definition.</li>
</ul>
<h3 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h3>
<ul>
<li><code>shared_crates/package_semantic/src/value.rs</code>: Specify how to parse TOML for a value of the type.</li>
<li><code>shared_crates/package_macro_common/src/concepts.rs</code>: Specify how to generate Rust code for a value of the type.</li>
</ul>
<h3 id="runtime-support"><a class="header" href="#runtime-support">Runtime support</a></h3>
<ul>
<li><code>shared_crates/package_rt/src/message_serde.rs</code>: Specify how to serialize and deserialize the type to a binary stream.
<ul>
<li>If this type is defined differently between the guest and the host, use the respective files:
<ul>
<li><code>crates/ecs/src/message_serde.rs</code></li>
<li><code>guest/rust/api_core/src/message/serde.rs</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="utilities"><a class="header" href="#utilities">Utilities</a></h3>
<ul>
<li><code>crates/wasm/src/shared/conversion.rs</code>: Add <code>IntoBindgen</code>/<code>FromBindgen</code> implementations if appropriate.</li>
<li><code>guest/rust/api_core/src/internal/conversion.rs</code>: Add <code>IntoBindgen</code>/<code>FromBindgen</code> implementations if appropriate.</li>
</ul>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li><code>CHANGELOG.md</code>: Document the addition of the new supported type.</li>
<li><code>docs/src/reference/package.md</code>: Document the new type in the components section.</li>
</ul>
<h2 id="golden-image-tests"><a class="header" href="#golden-image-tests">Golden image tests</a></h2>
<p>Golden image tests are a type of end-to-end test where a rendered image is captured and compared against an existing known-good image. This test is ran in our CI against all PRs, but you can also run it locally with <code>cargo campfire golden-images</code>.</p>
<h3 id="golden-images-on-ci"><a class="header" href="#golden-images-on-ci">Golden images on CI</a></h3>
<p>To debug why the CI fails, download the <code>screenshots.zip</code> file from the build artifacts, and look in the logs of the CI.
The <code>screenshots.zip</code> will show what image the CI produced.</p>
<h3 id="running-golden-images-locally"><a class="header" href="#running-golden-images-locally">Running golden images locally</a></h3>
<p>To update golden images, run <code>cargo campfire golden-images update</code>. This renders and saves a new set of golden images and replaces existing images.
To check against existing golden images, run <code>cargo campfire golden-images check</code>. This renders a new set of golden images and compares against existing images using a perceptual image difference metric.</p>
<h3 id="filtering-tests"><a class="header" href="#filtering-tests">Filtering tests</a></h3>
<p>Running <code>cargo campfire golden-images --prefix ui check</code> will only check tests which begin with <code>ui</code> prefix.</p>
<h3 id="common-failures"><a class="header" href="#common-failures">Common failures</a></h3>
<ul>
<li>If your test includes anything that animates over time, this is likely to fail the golden image test because the current golden image test implementation does not attempt to exactly synchronize
global time between runs. As a result, the test may never pass as the animation will never be in exactly the same pose. All tests should be static by default.</li>
</ul>
<h3 id="flakiness"><a class="header" href="#flakiness">Flakiness</a></h3>
<p>There are known situations where a test might fail seemingly randomly, even if the images look perceptually identical. These situations include:</p>
<ul>
<li>The golden image was generated on real graphics hardware - for example, on the contributor’s computer - while the CI version runs <code>llvmpipe</code>, which is a software rasterizer. This might cause small imperceptible differences. There are currently no clean solutions to this other than increasing the error threshold and/or re-generating the image using <code>golden-images update</code>.</li>
<li>Timing out. Each test runs with a timeout, which may fail the test if it takes too long to produce an image. On a powerful enough local machine, this might not be an issue, but execution times are less predictable in Github Actions. In these cases, the timeout can be increased or the test can be optimized.</li>
</ul>
<h2 id="releasing"><a class="header" href="#releasing">Releasing</a></h2>
<ol>
<li>Run <code>cargo campfire release update-version new_version_here</code> to update the Ambient version across the crates and documentation.</li>
<li>Run <code>cargo campfire doc runtime</code> to update the documentation from the codebase.</li>
<li>If a new system dependency was added, ensure it is added to <code>docs/src/installing.md</code> and <code>Dockerfile</code>.</li>
<li>Run <code>cargo campfire package check-all</code> and ensure all guest packages build without errors.</li>
<li>Run <code>cargo campfire package run-all</code> and visually verify that they work as expected.</li>
<li>Use <code>cargo campfire release check</code> to check that the release is ready.</li>
<li>Update the <code>CHANGELOG.md</code> at the root of the repository. Copy the unreleased block, set the version and date on the copy, and then empty out the unreleased block for the next release.</li>
<li>Make a commit with the above changes, and create a tag <code>v0.X.Y</code>.</li>
<li>Push to origin.</li>
<li>If this is a new major release (e.g. <code>0.2.0</code>), immediately update the version using <code>cargo campfire release update-version</code> to the next major release suffixed by dev (e.g. <code>0.3.0-dev</code>) and push that up (but do not tag it). This is to disambiguate in-development major releases from stable ones. If we need to update the released version, we will branch off from the release, cherry-pick relevant hotfixes, and cut a new release from that branch.</li>
<li>Update the tutorial and <a href="https://github.com/AmbientRun/TutorialProject">tutorial project</a> with the latest deployments. Ensure the version of the repository used for the website is updated, too.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs"><a class="header" href="#ecs">ECS</a></h1>
<p>The ECS is archetypal; each combination of components (e.g. <code>(translation, name, scale)</code> and <code>(translation, name, hitpoints)</code>) is a separate archetype, and each component is stored as a <code>Vec&lt;T&gt;</code> within the archetype.</p>
<h2 id="change-detection"><a class="header" href="#change-detection">Change detection</a></h2>
<p>At a conceptual level, we keep an circular buffer of all changes for each component/archetype. That means that doing a change query is extremely fast;
it will only need to iterate over the changes. However, a component can change twice or more in a frame, which should produce only one change event. To ensure this, we also keep track of the content version of each component for each entity.</p>
<h2 id="gpu-ecs"><a class="header" href="#gpu-ecs">GPU ECS</a></h2>
<p>The Ambient ECS also supports storing data on the GPU, through the <code>gpu_ecs</code> crate. This gives you a way to define components that live on the GPU,
and ways to synchronize data to those components.</p>
<p>CPU-to-GPU syncs are chunked, so in many cases it takes the same time to update one element as it does <code>CHUNK_SIZE</code> elements (currently 256).</p>
<h2 id="components-macro"><a class="header" href="#components-macro"><code>components!</code> macro</a></h2>
<p>At the root of the repository, there is an <code>ambient.toml</code> that defines all of the guest-visible components for Ambient. This is what runtime developers will typically add to when they want to add new components to Ambient.</p>
<p>However, there are some components that are not visible to guest code, but are still defined in host code. These components are defined using the <code>components!</code> macro. It is used like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>components!(&quot;app&quot;, {
    @[MakeDefault[default_title], Debuggable, MaybeResource]
    window_title: String,
    fps_stats: FpsSample,
});
<span class="boring">}
</span></code></pre></pre>
<p>Unlike <code>ambient.toml</code>, components can be of any type that meet a set of requirements. Additionally, the components defined here will not be visible to guest code. The attributes available are a superset of those available to <code>ambient.toml</code>.</p>
<p>These component definitions are primarily useful for internal data that needs to be attached to entities, but should not be or cannot be visible to guest code. For example, the <code>FpsSample</code> struct in the example above is a complex type and cannot be stored in a component in guest code, but it can be stored in a component in host code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="renderer"><a class="header" href="#renderer">Renderer</a></h1>
<p>The renderer is designed to be GPU-driven, where culling happens and draw calls are issued on the GPU. However, due to complications with some of our target platforms, we are currently handling these processes on the CPU, and the following documentation may not apply. We are working to rectify this.</p>
<p>Rendering a frame roughly looks like this:</p>
<ol>
<li>The <a href="runtime_internals/./ecs.html">GPU ECS</a> synchronizes any changed values to the GPU. Note: this only happens when values have changed, and is batched for performance.</li>
<li>The renderer runs culling. Only some entities are cullable; for instance, if you spawn a character which has a bunch of sub-entities (like a sword and a shield),
only the root entity will be culled. Culling happens entirely on the GPU.</li>
<li>We run the collect phase; this is per-primitive. Note that each entity may have multiple primitives. This also runs on the GPU, and the output is a compacted list
of draw calls.</li>
<li>On native, we run a <code>multi_draw_indirect_count</code> call for each shader/material configuration. Note that on native, the CPU does very little work each frame; most work
happens on the GPU and the CPU doesn’t need to wait for it. On web and macOS we currently don’t have access to <code>multi_draw_indirect_count</code>, so we’re currently dispatching
draw calls one by one, but we’re working on improvements to this.</li>
</ol>
<p>Some performance details:</p>
<ul>
<li>Per-entity data is <em>only</em> uploaded in the GPU ECS when the data changes. The rest of the renderer basically just needs to bind a shader and a material, and then draw all
objects.</li>
<li>The shadow renderer re-uses the same <code>TreeRenderer</code> for all cascades; it just switches which camera to use between them.</li>
<li>Culling is done for all entities and all renderer cameras (including the shadow cameras) in one compute shader pass.</li>
<li>Level-of-detail (LOD) selection is performed in the culling pass as well; it will select the LOD level. Each LOD is a separate primitive with a LOD index associated. The collect phase then only
picks the primitive with the LOD matching the one picked in the cull phase.</li>
<li>The renderer has been stress-tested in the past with hundreds of thousands of objects; see <a href="https://www.youtube.com/watch?v=jgkhsY8aZO8">this video</a> for an example. We hope to construct an example
that shows this off in the future, and to continue improving it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-cache"><a class="header" href="#asset-cache">Asset cache</a></h1>
<p>The <code>AssetCache</code> is a very central concept to the internals of the engine. It should be thought of as a way to <em>cache the result of slow operations</em> - that is, a memoization cache.</p>
<p>For example, let’s say we have:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_fractal(param1: bool, param2: u32) -&gt; Image {
    // ...
}

let fractal = generate_fractal(true, 5);
<span class="boring">}
</span></code></pre></pre>
<p>This function is entirely pure - that is, its output is only dependent on its inputs, and it will always return the same output for the same inputs. However, it’s also very slow to run. Instead of running it every time, the asset cache can be used to cache the result:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
struct GenerateFractal { param1: bool, param2: u32 }
impl SyncAssetKey&lt;Arc&lt;Image&gt;&gt; for GenerateFractal {
    fn load(&amp;self, assets: AssetCache) -&gt; Arc&lt;Arc&lt;Image&gt;&gt; {
        // ..
    }
}

let fractal = GenerateFractal { param2: true, param2: 5 }.get(&amp;assets);
<span class="boring">}
</span></code></pre></pre>
<p>The cache key is the debug format of <code>GenerateFractal</code>. This may change in the future, but it offers a simple way to construct a cache key for now.</p>
<h2 id="async"><a class="header" href="#async">Async</a></h2>
<p>The asset cache also works with <code>async</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
struct LoadImageFlipY { url: String }
#[async_trait]
impl AsyncAssetKey&lt;Arc&lt;Image&gt;&gt; for LoadImageFlipY {
    async fn load(&amp;self, assets: AssetCache) -&gt; Arc&lt;Image&gt; {
        let image = ImageFromUrl { url: self.url.clone() }.get(&amp;assets).await.unwrap();
        // ..
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that this will internally make sure that each unique key is only loaded once; that is, <code>load</code> above will be called once and persisted in the cache, and then the result will be returned for all subsequent calls, until it is evicted from the cache.</p>
<h2 id="keep-alive-policies"><a class="header" href="#keep-alive-policies">Keep-alive policies</a></h2>
<p>Different keep-alive policies for your cache key can be set by specifying the <code>keepalive</code> method in your trait implementation. This returns an <code>AssetKeepalive</code> which can be <code>None</code>, <code>Timeout</code>, or <code>Forever</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h1>
<p>This document contains guidelines for contributing to Ambient. These will be updated as the project evolves.</p>
<h2 id="message-style-errors-information"><a class="header" href="#message-style-errors-information">Message style (errors, information)</a></h2>
<p>When composing text that is shown to the user (including error messages and log messages), follow these guidelines:</p>
<ul>
<li>Use American English, as opposed to British English. This is the default for technical writing.
<ul>
<li><strong>Example</strong>: “color” is preferable to “colour”.</li>
</ul>
</li>
<li>Use the Oxford comma.
<ul>
<li><strong>Example</strong>: “red, white, and blue” is preferable to “red, white and blue”.</li>
</ul>
</li>
<li>Fully capitalize acronyms.
<ul>
<li><strong>Example</strong>: “HTTP” is preferable to “http” or “Http”.</li>
<li>Other common examples: “HTTP”, “URL”, “JSON”, “TOML”, “ECS”</li>
</ul>
</li>
<li>Use sentence case (i.e. capitalize the first word, and any proper nouns). Your errors could be at any layer of the stack, so they should read as complete sentences.
<ul>
<li><strong>Example</strong>: “Server running” is preferable to “server running”.</li>
</ul>
</li>
<li>Use the present tense if the message describes the current state of the system, or the past tense if it describes a past state.
<ul>
<li><strong>Example</strong>: “Server running” when the server’s started vs. “Server was running” when the server’s stopped.</li>
</ul>
</li>
<li>Use the imperative mood for commands.
<ul>
<li><strong>Example</strong>: “Run <code>cargo build</code> to build the project.” is preferable to “You can run <code>cargo build</code> to build the project.” as it is shorter and easier to read.</li>
</ul>
</li>
<li>Avoid being overly verbose, but don’t be terse to the point of confusion.
<ul>
<li><strong>Example</strong>: “Server running” is preferable to “The server is running” as it conveys the same amount of information, but is shorter and easier to read.</li>
<li><strong>Example</strong>: “Error while processing the frobnicator stack” is preferable to “Frobnicator stack processing error” as it provides specific information about the why (“while”) and the what (“the frobnicator stack”), while the latter is ambiguous and could be interpreted in multiple ways.</li>
</ul>
</li>
<li>Object IDs (packages, components, etc) should be referred to with surrounding backticks - except where already surrounded by parentheses - while names should be referred to with quotation marks.
<ul>
<li><strong>Example</strong>: <code>The package &quot;Party Starter&quot; (party_starter) does not have the component `boombox`.</code></li>
</ul>
</li>
<li>Paths should be referred to with quotation marks surrounding them. (The Rust debug implementation for paths does this automatically.)
<ul>
<li><strong>Example</strong>: <code>Your file is located at &quot;/home/user/file.txt&quot;.</code></li>
</ul>
</li>
<li>The additional context (e.g. <code>anyhow</code>, but this applies to anything where errors are being nested) for an error should be a complete message, not a fragment, as errors at any level of the stack may be displayed.
<ul>
<li><strong>Example</strong>: <code>Error while processing single pipeline in &quot;lol.toml&quot;: No such file or directory (os error 2)</code> is preferable to <code>In pipeline &quot;lol.toml&quot;: No such file or directory (os error 2)</code>.</li>
</ul>
</li>
<li>In general, try to optimize for easy copy-ability / clicking. If it’s a link, you should be able to click it in your terminal without having to manually select it.
<ul>
<li><strong>Example</strong>: <code>Visit `https://example.com/` for more information.</code> is preferable to <code>Visit https://example.com/ for more information.</code>, as the former is more likely to be clickable in a terminal.</li>
</ul>
</li>
<li>Use tracing instead of <code>println</code>. This is because many events within Ambient have a time component to them, and the output should convey that to ensure the user is aware of the time that the event occurred.
<ul>
<li><strong>Example</strong>: <code>tracing::info!(&quot;Server running&quot;)</code> is preferable to <code>println!(&quot;Server running&quot;)</code> as the latter does not convey the time that the event occurred. </li>
<li>Prefer <code>tracing::info!</code> for user facing events, and <code>tracing::debug!</code> or <code>tracing::trace!</code> for verbose information as the default log filter is <code>info</code>.</li>
</ul>
</li>
</ul>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h3>
<ul>
<li>Be careful with the use of <code>anyhow</code>, especially <code>context</code> and <code>with_context</code>. The context methods capture a backtrace for their error case, which can be expensive, especially if done in aggregate (i.e. in a hot loop). If your code is likely to discard the error, consider using a dedicated error type or <code>Option</code> instead.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
